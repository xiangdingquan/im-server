// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sessionpb.proto

package sessionpb // import "open.chat/app/interface/session/sessionpb"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import mtproto "open.chat/mtproto"

import strings "strings"
import reflect "reflect"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ClientKeyId struct {
	KeyId                int64    `protobuf:"varint,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	KeyType              int32    `protobuf:"varint,2,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	PermKeyId            int64    `protobuf:"varint,3,opt,name=perm_key_id,json=permKeyId,proto3" json:"perm_key_id,omitempty"`
	TempKeyId            int64    `protobuf:"varint,4,opt,name=temp_key_id,json=tempKeyId,proto3" json:"temp_key_id,omitempty"`
	MediaAuthKeyId       int64    `protobuf:"varint,5,opt,name=media_auth_key_id,json=mediaAuthKeyId,proto3" json:"media_auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientKeyId) Reset()         { *m = ClientKeyId{} }
func (m *ClientKeyId) String() string { return proto.CompactTextString(m) }
func (*ClientKeyId) ProtoMessage()    {}
func (*ClientKeyId) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{0}
}
func (m *ClientKeyId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientKeyId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientKeyId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientKeyId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientKeyId.Merge(dst, src)
}
func (m *ClientKeyId) XXX_Size() int {
	return m.Size()
}
func (m *ClientKeyId) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientKeyId.DiscardUnknown(m)
}

var xxx_messageInfo_ClientKeyId proto.InternalMessageInfo

func (m *ClientKeyId) GetKeyId() int64 {
	if m != nil {
		return m.KeyId
	}
	return 0
}

func (m *ClientKeyId) GetKeyType() int32 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

func (m *ClientKeyId) GetPermKeyId() int64 {
	if m != nil {
		return m.PermKeyId
	}
	return 0
}

func (m *ClientKeyId) GetTempKeyId() int64 {
	if m != nil {
		return m.TempKeyId
	}
	return 0
}

func (m *ClientKeyId) GetMediaAuthKeyId() int64 {
	if m != nil {
		return m.MediaAuthKeyId
	}
	return 0
}

type ClientConnData struct {
	ServerId             string       `protobuf:"bytes,1,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	ClientConnId         int64        `protobuf:"varint,2,opt,name=client_conn_id,json=clientConnId,proto3" json:"client_conn_id,omitempty"`
	ConnType             int32        `protobuf:"varint,3,opt,name=conn_type,json=connType,proto3" json:"conn_type,omitempty"`
	ClientAddr           string       `protobuf:"bytes,4,opt,name=client_addr,json=clientAddr,proto3" json:"client_addr,omitempty"`
	KeyId                *ClientKeyId `protobuf:"bytes,5,opt,name=key_id,json=keyId" json:"key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ClientConnData) Reset()         { *m = ClientConnData{} }
func (m *ClientConnData) String() string { return proto.CompactTextString(m) }
func (*ClientConnData) ProtoMessage()    {}
func (*ClientConnData) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{1}
}
func (m *ClientConnData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientConnData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientConnData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientConnData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientConnData.Merge(dst, src)
}
func (m *ClientConnData) XXX_Size() int {
	return m.Size()
}
func (m *ClientConnData) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientConnData.DiscardUnknown(m)
}

var xxx_messageInfo_ClientConnData proto.InternalMessageInfo

func (m *ClientConnData) GetServerId() string {
	if m != nil {
		return m.ServerId
	}
	return ""
}

func (m *ClientConnData) GetClientConnId() int64 {
	if m != nil {
		return m.ClientConnId
	}
	return 0
}

func (m *ClientConnData) GetConnType() int32 {
	if m != nil {
		return m.ConnType
	}
	return 0
}

func (m *ClientConnData) GetClientAddr() string {
	if m != nil {
		return m.ClientAddr
	}
	return ""
}

func (m *ClientConnData) GetKeyId() *ClientKeyId {
	if m != nil {
		return m.KeyId
	}
	return nil
}

type SessionClientEvent2 struct {
	Conn                 *ClientConnData `protobuf:"bytes,1,opt,name=conn" json:"conn,omitempty"`
	SessionId            int64           `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SessionClientEvent2) Reset()         { *m = SessionClientEvent2{} }
func (m *SessionClientEvent2) String() string { return proto.CompactTextString(m) }
func (*SessionClientEvent2) ProtoMessage()    {}
func (*SessionClientEvent2) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{2}
}
func (m *SessionClientEvent2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionClientEvent2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionClientEvent2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SessionClientEvent2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionClientEvent2.Merge(dst, src)
}
func (m *SessionClientEvent2) XXX_Size() int {
	return m.Size()
}
func (m *SessionClientEvent2) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionClientEvent2.DiscardUnknown(m)
}

var xxx_messageInfo_SessionClientEvent2 proto.InternalMessageInfo

func (m *SessionClientEvent2) GetConn() *ClientConnData {
	if m != nil {
		return m.Conn
	}
	return nil
}

func (m *SessionClientEvent2) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

type SessionClientEvent struct {
	ServerId             string   `protobuf:"bytes,1,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	ConnType             int32    `protobuf:"varint,2,opt,name=conn_type,json=connType,proto3" json:"conn_type,omitempty"`
	AuthKeyId            int64    `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	SessionId            int64    `protobuf:"varint,4,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ClientIp             string   `protobuf:"bytes,5,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionClientEvent) Reset()         { *m = SessionClientEvent{} }
func (m *SessionClientEvent) String() string { return proto.CompactTextString(m) }
func (*SessionClientEvent) ProtoMessage()    {}
func (*SessionClientEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{3}
}
func (m *SessionClientEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionClientEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionClientEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SessionClientEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionClientEvent.Merge(dst, src)
}
func (m *SessionClientEvent) XXX_Size() int {
	return m.Size()
}
func (m *SessionClientEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionClientEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SessionClientEvent proto.InternalMessageInfo

func (m *SessionClientEvent) GetServerId() string {
	if m != nil {
		return m.ServerId
	}
	return ""
}

func (m *SessionClientEvent) GetConnType() int32 {
	if m != nil {
		return m.ConnType
	}
	return 0
}

func (m *SessionClientEvent) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *SessionClientEvent) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SessionClientEvent) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

type SessionRedirect struct {
	Redirect             bool     `protobuf:"varint,1,opt,name=redirect,proto3" json:"redirect,omitempty"`
	BindPermAuthKeyId    int64    `protobuf:"varint,2,opt,name=bind_perm_auth_key_id,json=bindPermAuthKeyId,proto3" json:"bind_perm_auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionRedirect) Reset()         { *m = SessionRedirect{} }
func (m *SessionRedirect) String() string { return proto.CompactTextString(m) }
func (*SessionRedirect) ProtoMessage()    {}
func (*SessionRedirect) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{4}
}
func (m *SessionRedirect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionRedirect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionRedirect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SessionRedirect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionRedirect.Merge(dst, src)
}
func (m *SessionRedirect) XXX_Size() int {
	return m.Size()
}
func (m *SessionRedirect) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionRedirect.DiscardUnknown(m)
}

var xxx_messageInfo_SessionRedirect proto.InternalMessageInfo

func (m *SessionRedirect) GetRedirect() bool {
	if m != nil {
		return m.Redirect
	}
	return false
}

func (m *SessionRedirect) GetBindPermAuthKeyId() int64 {
	if m != nil {
		return m.BindPermAuthKeyId
	}
	return 0
}

type AuthSessionIdList struct {
	ServerId             string   `protobuf:"bytes,1,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	ConnType             int32    `protobuf:"varint,2,opt,name=conn_type,json=connType,proto3" json:"conn_type,omitempty"`
	AuthKeyId            int64    `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	SessionIdList        []int32  `protobuf:"varint,4,rep,packed,name=session_id_list,json=sessionIdList" json:"session_id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthSessionIdList) Reset()         { *m = AuthSessionIdList{} }
func (m *AuthSessionIdList) String() string { return proto.CompactTextString(m) }
func (*AuthSessionIdList) ProtoMessage()    {}
func (*AuthSessionIdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{5}
}
func (m *AuthSessionIdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthSessionIdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthSessionIdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AuthSessionIdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthSessionIdList.Merge(dst, src)
}
func (m *AuthSessionIdList) XXX_Size() int {
	return m.Size()
}
func (m *AuthSessionIdList) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthSessionIdList.DiscardUnknown(m)
}

var xxx_messageInfo_AuthSessionIdList proto.InternalMessageInfo

func (m *AuthSessionIdList) GetServerId() string {
	if m != nil {
		return m.ServerId
	}
	return ""
}

func (m *AuthSessionIdList) GetConnType() int32 {
	if m != nil {
		return m.ConnType
	}
	return 0
}

func (m *AuthSessionIdList) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *AuthSessionIdList) GetSessionIdList() []int32 {
	if m != nil {
		return m.SessionIdList
	}
	return nil
}

type AuthId struct {
	AuthKeyId            int64    `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthId) Reset()         { *m = AuthId{} }
func (m *AuthId) String() string { return proto.CompactTextString(m) }
func (*AuthId) ProtoMessage()    {}
func (*AuthId) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{6}
}
func (m *AuthId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AuthId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthId.Merge(dst, src)
}
func (m *AuthId) XXX_Size() int {
	return m.Size()
}
func (m *AuthId) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthId.DiscardUnknown(m)
}

var xxx_messageInfo_AuthId proto.InternalMessageInfo

func (m *AuthId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

type SessionClientData struct {
	ServerId             string   `protobuf:"bytes,1,opt,name=server_id,json=serverId,proto3" json:"server_id,omitempty"`
	ClientIp             string   `protobuf:"bytes,3,opt,name=client_ip,json=clientIp,proto3" json:"client_ip,omitempty"`
	ConnType             int32    `protobuf:"varint,4,opt,name=conn_type,json=connType,proto3" json:"conn_type,omitempty"`
	AuthKeyId            int64    `protobuf:"varint,5,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	QuickAck             int32    `protobuf:"varint,6,opt,name=quick_ack,json=quickAck,proto3" json:"quick_ack,omitempty"`
	SessionId            int64    `protobuf:"varint,7,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Salt                 int64    `protobuf:"varint,8,opt,name=salt,proto3" json:"salt,omitempty"`
	Payload              []byte   `protobuf:"bytes,9,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionClientData) Reset()         { *m = SessionClientData{} }
func (m *SessionClientData) String() string { return proto.CompactTextString(m) }
func (*SessionClientData) ProtoMessage()    {}
func (*SessionClientData) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{7}
}
func (m *SessionClientData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionClientData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionClientData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SessionClientData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionClientData.Merge(dst, src)
}
func (m *SessionClientData) XXX_Size() int {
	return m.Size()
}
func (m *SessionClientData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionClientData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionClientData proto.InternalMessageInfo

func (m *SessionClientData) GetServerId() string {
	if m != nil {
		return m.ServerId
	}
	return ""
}

func (m *SessionClientData) GetClientIp() string {
	if m != nil {
		return m.ClientIp
	}
	return ""
}

func (m *SessionClientData) GetConnType() int32 {
	if m != nil {
		return m.ConnType
	}
	return 0
}

func (m *SessionClientData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *SessionClientData) GetQuickAck() int32 {
	if m != nil {
		return m.QuickAck
	}
	return 0
}

func (m *SessionClientData) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SessionClientData) GetSalt() int64 {
	if m != nil {
		return m.Salt
	}
	return 0
}

func (m *SessionClientData) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SessionClientData2 struct {
	Conn                 *ClientConnData `protobuf:"bytes,1,opt,name=conn" json:"conn,omitempty"`
	QuickAck             int32           `protobuf:"varint,2,opt,name=quick_ack,json=quickAck,proto3" json:"quick_ack,omitempty"`
	SessionId            int64           `protobuf:"varint,3,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Salt                 int64           `protobuf:"varint,4,opt,name=salt,proto3" json:"salt,omitempty"`
	Payload              []byte          `protobuf:"bytes,5,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SessionClientData2) Reset()         { *m = SessionClientData2{} }
func (m *SessionClientData2) String() string { return proto.CompactTextString(m) }
func (*SessionClientData2) ProtoMessage()    {}
func (*SessionClientData2) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{8}
}
func (m *SessionClientData2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionClientData2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionClientData2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SessionClientData2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionClientData2.Merge(dst, src)
}
func (m *SessionClientData2) XXX_Size() int {
	return m.Size()
}
func (m *SessionClientData2) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionClientData2.DiscardUnknown(m)
}

var xxx_messageInfo_SessionClientData2 proto.InternalMessageInfo

func (m *SessionClientData2) GetConn() *ClientConnData {
	if m != nil {
		return m.Conn
	}
	return nil
}

func (m *SessionClientData2) GetQuickAck() int32 {
	if m != nil {
		return m.QuickAck
	}
	return 0
}

func (m *SessionClientData2) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *SessionClientData2) GetSalt() int64 {
	if m != nil {
		return m.Salt
	}
	return 0
}

func (m *SessionClientData2) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type SessionData struct {
	Payload              []byte   `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SessionData) Reset()         { *m = SessionData{} }
func (m *SessionData) String() string { return proto.CompactTextString(m) }
func (*SessionData) ProtoMessage()    {}
func (*SessionData) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{9}
}
func (m *SessionData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SessionData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SessionData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SessionData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SessionData.Merge(dst, src)
}
func (m *SessionData) XXX_Size() int {
	return m.Size()
}
func (m *SessionData) XXX_DiscardUnknown() {
	xxx_messageInfo_SessionData.DiscardUnknown(m)
}

var xxx_messageInfo_SessionData proto.InternalMessageInfo

func (m *SessionData) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// --------------------------------------------------------------------------------------------
// authKeyInfo flags:# auth_key_id:long auth_key:bytes future_salt:flags.0?FutureSalt= AuthKeyInfo;
//
// AuthKeyInfo <--
//   - TL_authKeyInfo
type AuthKeyInfo struct {
	AuthKeyId            int64    `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	AuthKey              []byte   `protobuf:"bytes,4,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	AuthKeyType          int32    `protobuf:"varint,5,opt,name=auth_key_type,json=authKeyType,proto3" json:"auth_key_type,omitempty"`
	PermAuthKeyId        int64    `protobuf:"varint,6,opt,name=perm_auth_key_id,json=permAuthKeyId,proto3" json:"perm_auth_key_id,omitempty"`
	TempAuthKeyId        int64    `protobuf:"varint,7,opt,name=temp_auth_key_id,json=tempAuthKeyId,proto3" json:"temp_auth_key_id,omitempty"`
	MediaTempAuthKeyId   int64    `protobuf:"varint,8,opt,name=media_temp_auth_key_id,json=mediaTempAuthKeyId,proto3" json:"media_temp_auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthKeyInfo) Reset()         { *m = AuthKeyInfo{} }
func (m *AuthKeyInfo) String() string { return proto.CompactTextString(m) }
func (*AuthKeyInfo) ProtoMessage()    {}
func (*AuthKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{10}
}
func (m *AuthKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AuthKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthKeyInfo.Merge(dst, src)
}
func (m *AuthKeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *AuthKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthKeyInfo proto.InternalMessageInfo

func (m *AuthKeyInfo) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *AuthKeyInfo) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *AuthKeyInfo) GetAuthKeyType() int32 {
	if m != nil {
		return m.AuthKeyType
	}
	return 0
}

func (m *AuthKeyInfo) GetPermAuthKeyId() int64 {
	if m != nil {
		return m.PermAuthKeyId
	}
	return 0
}

func (m *AuthKeyInfo) GetTempAuthKeyId() int64 {
	if m != nil {
		return m.TempAuthKeyId
	}
	return 0
}

func (m *AuthKeyInfo) GetMediaTempAuthKeyId() int64 {
	if m != nil {
		return m.MediaTempAuthKeyId
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.setAuthKey auth_key:AuthKeyInfo = Bool;
type AuthKeySalts struct {
	AuthKey              *AuthKeyInfo        `protobuf:"bytes,2,opt,name=auth_key,json=authKey" json:"auth_key,omitempty"`
	FutureSalt           *mtproto.FutureSalt `protobuf:"bytes,3,opt,name=future_salt,json=futureSalt" json:"future_salt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *AuthKeySalts) Reset()         { *m = AuthKeySalts{} }
func (m *AuthKeySalts) String() string { return proto.CompactTextString(m) }
func (*AuthKeySalts) ProtoMessage()    {}
func (*AuthKeySalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{11}
}
func (m *AuthKeySalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthKeySalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthKeySalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AuthKeySalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthKeySalts.Merge(dst, src)
}
func (m *AuthKeySalts) XXX_Size() int {
	return m.Size()
}
func (m *AuthKeySalts) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthKeySalts.DiscardUnknown(m)
}

var xxx_messageInfo_AuthKeySalts proto.InternalMessageInfo

func (m *AuthKeySalts) GetAuthKey() *AuthKeyInfo {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *AuthKeySalts) GetFutureSalt() *mtproto.FutureSalt {
	if m != nil {
		return m.FutureSalt
	}
	return nil
}

// --------------------------------------------------------------------------------------------
// push.pushUpdatesData auth_key_id:long pts:int pts_count:int updates:Updates = Bool;
type PushUpdatesData struct {
	AuthKeyId            int64            `protobuf:"varint,1,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Notification         bool             `protobuf:"varint,2,opt,name=notification,proto3" json:"notification,omitempty"`
	Updates              *mtproto.Updates `protobuf:"bytes,3,opt,name=updates" json:"updates,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PushUpdatesData) Reset()         { *m = PushUpdatesData{} }
func (m *PushUpdatesData) String() string { return proto.CompactTextString(m) }
func (*PushUpdatesData) ProtoMessage()    {}
func (*PushUpdatesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{12}
}
func (m *PushUpdatesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushUpdatesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushUpdatesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PushUpdatesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushUpdatesData.Merge(dst, src)
}
func (m *PushUpdatesData) XXX_Size() int {
	return m.Size()
}
func (m *PushUpdatesData) XXX_DiscardUnknown() {
	xxx_messageInfo_PushUpdatesData.DiscardUnknown(m)
}

var xxx_messageInfo_PushUpdatesData proto.InternalMessageInfo

func (m *PushUpdatesData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *PushUpdatesData) GetNotification() bool {
	if m != nil {
		return m.Notification
	}
	return false
}

func (m *PushUpdatesData) GetUpdates() *mtproto.Updates {
	if m != nil {
		return m.Updates
	}
	return nil
}

type PushSessionUpdatesData struct {
	AuthKeyId            int64            `protobuf:"varint,1,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	SessionId            int64            `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Updates              *mtproto.Updates `protobuf:"bytes,3,opt,name=updates" json:"updates,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PushSessionUpdatesData) Reset()         { *m = PushSessionUpdatesData{} }
func (m *PushSessionUpdatesData) String() string { return proto.CompactTextString(m) }
func (*PushSessionUpdatesData) ProtoMessage()    {}
func (*PushSessionUpdatesData) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{13}
}
func (m *PushSessionUpdatesData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushSessionUpdatesData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushSessionUpdatesData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PushSessionUpdatesData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushSessionUpdatesData.Merge(dst, src)
}
func (m *PushSessionUpdatesData) XXX_Size() int {
	return m.Size()
}
func (m *PushSessionUpdatesData) XXX_DiscardUnknown() {
	xxx_messageInfo_PushSessionUpdatesData.DiscardUnknown(m)
}

var xxx_messageInfo_PushSessionUpdatesData proto.InternalMessageInfo

func (m *PushSessionUpdatesData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *PushSessionUpdatesData) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *PushSessionUpdatesData) GetUpdates() *mtproto.Updates {
	if m != nil {
		return m.Updates
	}
	return nil
}

// --------------------------------------------------------------------------------------------
// push.pushRpcResultData auth_key_id:long client_req_msg_id:long = Bool;
type PushRpcResultData struct {
	AuthKeyId            int64    `protobuf:"varint,1,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	SessionId            int64    `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ClientReqMsgId       int64    `protobuf:"varint,3,opt,name=client_req_msg_id,json=clientReqMsgId,proto3" json:"client_req_msg_id,omitempty"`
	RpcResultData        []byte   `protobuf:"bytes,4,opt,name=rpc_result_data,json=rpcResultData,proto3" json:"rpc_result_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PushRpcResultData) Reset()         { *m = PushRpcResultData{} }
func (m *PushRpcResultData) String() string { return proto.CompactTextString(m) }
func (*PushRpcResultData) ProtoMessage()    {}
func (*PushRpcResultData) Descriptor() ([]byte, []int) {
	return fileDescriptor_sessionpb_f41fee5d2690f54f, []int{14}
}
func (m *PushRpcResultData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PushRpcResultData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PushRpcResultData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PushRpcResultData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PushRpcResultData.Merge(dst, src)
}
func (m *PushRpcResultData) XXX_Size() int {
	return m.Size()
}
func (m *PushRpcResultData) XXX_DiscardUnknown() {
	xxx_messageInfo_PushRpcResultData.DiscardUnknown(m)
}

var xxx_messageInfo_PushRpcResultData proto.InternalMessageInfo

func (m *PushRpcResultData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *PushRpcResultData) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *PushRpcResultData) GetClientReqMsgId() int64 {
	if m != nil {
		return m.ClientReqMsgId
	}
	return 0
}

func (m *PushRpcResultData) GetRpcResultData() []byte {
	if m != nil {
		return m.RpcResultData
	}
	return nil
}

func init() {
	proto.RegisterType((*ClientKeyId)(nil), "sessionpb.ClientKeyId")
	proto.RegisterType((*ClientConnData)(nil), "sessionpb.ClientConnData")
	proto.RegisterType((*SessionClientEvent2)(nil), "sessionpb.SessionClientEvent2")
	proto.RegisterType((*SessionClientEvent)(nil), "sessionpb.SessionClientEvent")
	proto.RegisterType((*SessionRedirect)(nil), "sessionpb.SessionRedirect")
	proto.RegisterType((*AuthSessionIdList)(nil), "sessionpb.AuthSessionIdList")
	proto.RegisterType((*AuthId)(nil), "sessionpb.AuthId")
	proto.RegisterType((*SessionClientData)(nil), "sessionpb.SessionClientData")
	proto.RegisterType((*SessionClientData2)(nil), "sessionpb.SessionClientData2")
	proto.RegisterType((*SessionData)(nil), "sessionpb.SessionData")
	proto.RegisterType((*AuthKeyInfo)(nil), "sessionpb.AuthKeyInfo")
	proto.RegisterType((*AuthKeySalts)(nil), "sessionpb.AuthKeySalts")
	proto.RegisterType((*PushUpdatesData)(nil), "sessionpb.PushUpdatesData")
	proto.RegisterType((*PushSessionUpdatesData)(nil), "sessionpb.PushSessionUpdatesData")
	proto.RegisterType((*PushRpcResultData)(nil), "sessionpb.PushRpcResultData")
}
func (this *ClientKeyId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&sessionpb.ClientKeyId{")
	s = append(s, "KeyId: "+fmt.Sprintf("%#v", this.KeyId)+",")
	s = append(s, "KeyType: "+fmt.Sprintf("%#v", this.KeyType)+",")
	s = append(s, "PermKeyId: "+fmt.Sprintf("%#v", this.PermKeyId)+",")
	s = append(s, "TempKeyId: "+fmt.Sprintf("%#v", this.TempKeyId)+",")
	s = append(s, "MediaAuthKeyId: "+fmt.Sprintf("%#v", this.MediaAuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClientConnData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&sessionpb.ClientConnData{")
	s = append(s, "ServerId: "+fmt.Sprintf("%#v", this.ServerId)+",")
	s = append(s, "ClientConnId: "+fmt.Sprintf("%#v", this.ClientConnId)+",")
	s = append(s, "ConnType: "+fmt.Sprintf("%#v", this.ConnType)+",")
	s = append(s, "ClientAddr: "+fmt.Sprintf("%#v", this.ClientAddr)+",")
	if this.KeyId != nil {
		s = append(s, "KeyId: "+fmt.Sprintf("%#v", this.KeyId)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionClientEvent2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&sessionpb.SessionClientEvent2{")
	if this.Conn != nil {
		s = append(s, "Conn: "+fmt.Sprintf("%#v", this.Conn)+",")
	}
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionClientEvent) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&sessionpb.SessionClientEvent{")
	s = append(s, "ServerId: "+fmt.Sprintf("%#v", this.ServerId)+",")
	s = append(s, "ConnType: "+fmt.Sprintf("%#v", this.ConnType)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",")
	s = append(s, "ClientIp: "+fmt.Sprintf("%#v", this.ClientIp)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionRedirect) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&sessionpb.SessionRedirect{")
	s = append(s, "Redirect: "+fmt.Sprintf("%#v", this.Redirect)+",")
	s = append(s, "BindPermAuthKeyId: "+fmt.Sprintf("%#v", this.BindPermAuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthSessionIdList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&sessionpb.AuthSessionIdList{")
	s = append(s, "ServerId: "+fmt.Sprintf("%#v", this.ServerId)+",")
	s = append(s, "ConnType: "+fmt.Sprintf("%#v", this.ConnType)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "SessionIdList: "+fmt.Sprintf("%#v", this.SessionIdList)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&sessionpb.AuthId{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionClientData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&sessionpb.SessionClientData{")
	s = append(s, "ServerId: "+fmt.Sprintf("%#v", this.ServerId)+",")
	s = append(s, "ClientIp: "+fmt.Sprintf("%#v", this.ClientIp)+",")
	s = append(s, "ConnType: "+fmt.Sprintf("%#v", this.ConnType)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "QuickAck: "+fmt.Sprintf("%#v", this.QuickAck)+",")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",")
	s = append(s, "Salt: "+fmt.Sprintf("%#v", this.Salt)+",")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionClientData2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&sessionpb.SessionClientData2{")
	if this.Conn != nil {
		s = append(s, "Conn: "+fmt.Sprintf("%#v", this.Conn)+",")
	}
	s = append(s, "QuickAck: "+fmt.Sprintf("%#v", this.QuickAck)+",")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",")
	s = append(s, "Salt: "+fmt.Sprintf("%#v", this.Salt)+",")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SessionData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&sessionpb.SessionData{")
	s = append(s, "Payload: "+fmt.Sprintf("%#v", this.Payload)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthKeyInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&sessionpb.AuthKeyInfo{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "AuthKey: "+fmt.Sprintf("%#v", this.AuthKey)+",")
	s = append(s, "AuthKeyType: "+fmt.Sprintf("%#v", this.AuthKeyType)+",")
	s = append(s, "PermAuthKeyId: "+fmt.Sprintf("%#v", this.PermAuthKeyId)+",")
	s = append(s, "TempAuthKeyId: "+fmt.Sprintf("%#v", this.TempAuthKeyId)+",")
	s = append(s, "MediaTempAuthKeyId: "+fmt.Sprintf("%#v", this.MediaTempAuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthKeySalts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&sessionpb.AuthKeySalts{")
	if this.AuthKey != nil {
		s = append(s, "AuthKey: "+fmt.Sprintf("%#v", this.AuthKey)+",")
	}
	if this.FutureSalt != nil {
		s = append(s, "FutureSalt: "+fmt.Sprintf("%#v", this.FutureSalt)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PushUpdatesData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&sessionpb.PushUpdatesData{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "Notification: "+fmt.Sprintf("%#v", this.Notification)+",")
	if this.Updates != nil {
		s = append(s, "Updates: "+fmt.Sprintf("%#v", this.Updates)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PushSessionUpdatesData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&sessionpb.PushSessionUpdatesData{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",")
	if this.Updates != nil {
		s = append(s, "Updates: "+fmt.Sprintf("%#v", this.Updates)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PushRpcResultData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&sessionpb.PushRpcResultData{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "SessionId: "+fmt.Sprintf("%#v", this.SessionId)+",")
	s = append(s, "ClientReqMsgId: "+fmt.Sprintf("%#v", this.ClientReqMsgId)+",")
	s = append(s, "RpcResultData: "+fmt.Sprintf("%#v", this.RpcResultData)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringSessionpb(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCSessionClient is the client API for RPCSession service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCSessionClient interface {
	CreateSession(ctx context.Context, in *SessionClientEvent, opts ...grpc.CallOption) (*mtproto.Bool, error)
	CloseSession(ctx context.Context, in *SessionClientEvent, opts ...grpc.CallOption) (*mtproto.Bool, error)
	SendAsyncSessionData(ctx context.Context, in *SessionClientData, opts ...grpc.CallOption) (*mtproto.Bool, error)
	SendSyncSessionData(ctx context.Context, in *SessionClientData, opts ...grpc.CallOption) (*SessionData, error)
	Heartbeat(ctx context.Context, in *SessionClientEvent, opts ...grpc.CallOption) (*mtproto.Bool, error)
	DestroySessions(ctx context.Context, in *AuthId, opts ...grpc.CallOption) (*mtproto.Bool, error)
	ImportSessions(ctx context.Context, in *AuthSessionIdList, opts ...grpc.CallOption) (*mtproto.Bool, error)
	SessionQueryAuthKey(ctx context.Context, in *AuthId, opts ...grpc.CallOption) (*AuthKeyInfo, error)
	SessionSetAuthKey(ctx context.Context, in *AuthKeySalts, opts ...grpc.CallOption) (*mtproto.Bool, error)
}

type rPCSessionClient struct {
	cc *grpc.ClientConn
}

func NewRPCSessionClient(cc *grpc.ClientConn) RPCSessionClient {
	return &rPCSessionClient{cc}
}

func (c *rPCSessionClient) CreateSession(ctx context.Context, in *SessionClientEvent, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/CreateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) CloseSession(ctx context.Context, in *SessionClientEvent, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/CloseSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SendAsyncSessionData(ctx context.Context, in *SessionClientData, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/SendAsyncSessionData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SendSyncSessionData(ctx context.Context, in *SessionClientData, opts ...grpc.CallOption) (*SessionData, error) {
	out := new(SessionData)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/SendSyncSessionData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) Heartbeat(ctx context.Context, in *SessionClientEvent, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/Heartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) DestroySessions(ctx context.Context, in *AuthId, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/DestroySessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) ImportSessions(ctx context.Context, in *AuthSessionIdList, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/ImportSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionQueryAuthKey(ctx context.Context, in *AuthId, opts ...grpc.CallOption) (*AuthKeyInfo, error) {
	out := new(AuthKeyInfo)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/session_queryAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionSetAuthKey(ctx context.Context, in *AuthKeySalts, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCSession/session_setAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RPCSession service

type RPCSessionServer interface {
	CreateSession(context.Context, *SessionClientEvent) (*mtproto.Bool, error)
	CloseSession(context.Context, *SessionClientEvent) (*mtproto.Bool, error)
	SendAsyncSessionData(context.Context, *SessionClientData) (*mtproto.Bool, error)
	SendSyncSessionData(context.Context, *SessionClientData) (*SessionData, error)
	Heartbeat(context.Context, *SessionClientEvent) (*mtproto.Bool, error)
	DestroySessions(context.Context, *AuthId) (*mtproto.Bool, error)
	ImportSessions(context.Context, *AuthSessionIdList) (*mtproto.Bool, error)
	SessionQueryAuthKey(context.Context, *AuthId) (*AuthKeyInfo, error)
	SessionSetAuthKey(context.Context, *AuthKeySalts) (*mtproto.Bool, error)
}

func RegisterRPCSessionServer(s *grpc.Server, srv RPCSessionServer) {
	s.RegisterService(&_RPCSession_serviceDesc, srv)
}

func _RPCSession_CreateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionClientEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).CreateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/CreateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).CreateSession(ctx, req.(*SessionClientEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_CloseSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionClientEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).CloseSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/CloseSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).CloseSession(ctx, req.(*SessionClientEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SendAsyncSessionData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionClientData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SendAsyncSessionData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/SendAsyncSessionData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SendAsyncSessionData(ctx, req.(*SessionClientData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SendSyncSessionData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionClientData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SendSyncSessionData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/SendSyncSessionData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SendSyncSessionData(ctx, req.(*SessionClientData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SessionClientEvent)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/Heartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).Heartbeat(ctx, req.(*SessionClientEvent))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_DestroySessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).DestroySessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/DestroySessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).DestroySessions(ctx, req.(*AuthId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_ImportSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthSessionIdList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).ImportSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/ImportSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).ImportSessions(ctx, req.(*AuthSessionIdList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionQueryAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionQueryAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/SessionQueryAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionQueryAuthKey(ctx, req.(*AuthId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionSetAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthKeySalts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionSetAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCSession/SessionSetAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionSetAuthKey(ctx, req.(*AuthKeySalts))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCSession_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sessionpb.RPCSession",
	HandlerType: (*RPCSessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSession",
			Handler:    _RPCSession_CreateSession_Handler,
		},
		{
			MethodName: "CloseSession",
			Handler:    _RPCSession_CloseSession_Handler,
		},
		{
			MethodName: "SendAsyncSessionData",
			Handler:    _RPCSession_SendAsyncSessionData_Handler,
		},
		{
			MethodName: "SendSyncSessionData",
			Handler:    _RPCSession_SendSyncSessionData_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _RPCSession_Heartbeat_Handler,
		},
		{
			MethodName: "DestroySessions",
			Handler:    _RPCSession_DestroySessions_Handler,
		},
		{
			MethodName: "ImportSessions",
			Handler:    _RPCSession_ImportSessions_Handler,
		},
		{
			MethodName: "session_queryAuthKey",
			Handler:    _RPCSession_SessionQueryAuthKey_Handler,
		},
		{
			MethodName: "session_setAuthKey",
			Handler:    _RPCSession_SessionSetAuthKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sessionpb.proto",
}

// RPCPushClient is the client API for RPCPush service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCPushClient interface {
	PushUpdates(ctx context.Context, in *PushUpdatesData, opts ...grpc.CallOption) (*mtproto.Bool, error)
	PushRpcResult(ctx context.Context, in *PushRpcResultData, opts ...grpc.CallOption) (*mtproto.Bool, error)
	PushSessionUpdates(ctx context.Context, in *PushSessionUpdatesData, opts ...grpc.CallOption) (*mtproto.Bool, error)
}

type rPCPushClient struct {
	cc *grpc.ClientConn
}

func NewRPCPushClient(cc *grpc.ClientConn) RPCPushClient {
	return &rPCPushClient{cc}
}

func (c *rPCPushClient) PushUpdates(ctx context.Context, in *PushUpdatesData, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCPush/PushUpdates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCPushClient) PushRpcResult(ctx context.Context, in *PushRpcResultData, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCPush/PushRpcResult", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCPushClient) PushSessionUpdates(ctx context.Context, in *PushSessionUpdatesData, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/sessionpb.RPCPush/PushSessionUpdates", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RPCPush service

type RPCPushServer interface {
	PushUpdates(context.Context, *PushUpdatesData) (*mtproto.Bool, error)
	PushRpcResult(context.Context, *PushRpcResultData) (*mtproto.Bool, error)
	PushSessionUpdates(context.Context, *PushSessionUpdatesData) (*mtproto.Bool, error)
}

func RegisterRPCPushServer(s *grpc.Server, srv RPCPushServer) {
	s.RegisterService(&_RPCPush_serviceDesc, srv)
}

func _RPCPush_PushUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushUpdatesData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCPushServer).PushUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCPush/PushUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCPushServer).PushUpdates(ctx, req.(*PushUpdatesData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCPush_PushRpcResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRpcResultData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCPushServer).PushRpcResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCPush/PushRpcResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCPushServer).PushRpcResult(ctx, req.(*PushRpcResultData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCPush_PushSessionUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushSessionUpdatesData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCPushServer).PushSessionUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sessionpb.RPCPush/PushSessionUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCPushServer).PushSessionUpdates(ctx, req.(*PushSessionUpdatesData))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCPush_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sessionpb.RPCPush",
	HandlerType: (*RPCPushServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PushUpdates",
			Handler:    _RPCPush_PushUpdates_Handler,
		},
		{
			MethodName: "PushRpcResult",
			Handler:    _RPCPush_PushRpcResult_Handler,
		},
		{
			MethodName: "PushSessionUpdates",
			Handler:    _RPCPush_PushSessionUpdates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sessionpb.proto",
}

func (m *ClientKeyId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientKeyId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.KeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.KeyId))
	}
	if m.KeyType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.KeyType))
	}
	if m.PermKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.PermKeyId))
	}
	if m.TempKeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.TempKeyId))
	}
	if m.MediaAuthKeyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.MediaAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientConnData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientConnData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.ServerId)))
		i += copy(dAtA[i:], m.ServerId)
	}
	if m.ClientConnId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.ClientConnId))
	}
	if m.ConnType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.ConnType))
	}
	if len(m.ClientAddr) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.ClientAddr)))
		i += copy(dAtA[i:], m.ClientAddr)
	}
	if m.KeyId != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.KeyId.Size()))
		n1, err := m.KeyId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionClientEvent2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionClientEvent2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.Conn.Size()))
		n2, err := m.Conn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.SessionId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionClientEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionClientEvent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.ServerId)))
		i += copy(dAtA[i:], m.ServerId)
	}
	if m.ConnType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.ConnType))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.SessionId))
	}
	if len(m.ClientIp) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.ClientIp)))
		i += copy(dAtA[i:], m.ClientIp)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionRedirect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionRedirect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Redirect {
		dAtA[i] = 0x8
		i++
		if m.Redirect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BindPermAuthKeyId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.BindPermAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthSessionIdList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthSessionIdList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.ServerId)))
		i += copy(dAtA[i:], m.ServerId)
	}
	if m.ConnType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.ConnType))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if len(m.SessionIdList) > 0 {
		dAtA4 := make([]byte, len(m.SessionIdList)*10)
		var j3 int
		for _, num1 := range m.SessionIdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionClientData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionClientData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ServerId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.ServerId)))
		i += copy(dAtA[i:], m.ServerId)
	}
	if len(m.ClientIp) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.ClientIp)))
		i += copy(dAtA[i:], m.ClientIp)
	}
	if m.ConnType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.ConnType))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.QuickAck != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.QuickAck))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.SessionId))
	}
	if m.Salt != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.Salt))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionClientData2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionClientData2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Conn != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.Conn.Size()))
		n5, err := m.Conn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.QuickAck != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.QuickAck))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.SessionId))
	}
	if m.Salt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.Salt))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SessionData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SessionData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if m.AuthKeyType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyType))
	}
	if m.PermAuthKeyId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.PermAuthKeyId))
	}
	if m.TempAuthKeyId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.TempAuthKeyId))
	}
	if m.MediaTempAuthKeyId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.MediaTempAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthKeySalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthKeySalts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKey.Size()))
		n6, err := m.AuthKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.FutureSalt != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.FutureSalt.Size()))
		n7, err := m.FutureSalt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PushUpdatesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushUpdatesData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.Notification {
		dAtA[i] = 0x10
		i++
		if m.Notification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Updates != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.Updates.Size()))
		n8, err := m.Updates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PushSessionUpdatesData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushSessionUpdatesData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.SessionId))
	}
	if m.Updates != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.Updates.Size()))
		n9, err := m.Updates.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PushRpcResultData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PushRpcResultData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.SessionId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.SessionId))
	}
	if m.ClientReqMsgId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(m.ClientReqMsgId))
	}
	if len(m.RpcResultData) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintSessionpb(dAtA, i, uint64(len(m.RpcResultData)))
		i += copy(dAtA[i:], m.RpcResultData)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintSessionpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ClientKeyId) Size() (n int) {
	var l int
	_ = l
	if m.KeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.KeyId))
	}
	if m.KeyType != 0 {
		n += 1 + sovSessionpb(uint64(m.KeyType))
	}
	if m.PermKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.PermKeyId))
	}
	if m.TempKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.TempKeyId))
	}
	if m.MediaAuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.MediaAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientConnData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.ClientConnId != 0 {
		n += 1 + sovSessionpb(uint64(m.ClientConnId))
	}
	if m.ConnType != 0 {
		n += 1 + sovSessionpb(uint64(m.ConnType))
	}
	l = len(m.ClientAddr)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.KeyId != nil {
		l = m.KeyId.Size()
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionClientEvent2) Size() (n int) {
	var l int
	_ = l
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovSessionpb(uint64(m.SessionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionClientEvent) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.ConnType != 0 {
		n += 1 + sovSessionpb(uint64(m.ConnType))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	if m.SessionId != 0 {
		n += 1 + sovSessionpb(uint64(m.SessionId))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionRedirect) Size() (n int) {
	var l int
	_ = l
	if m.Redirect {
		n += 2
	}
	if m.BindPermAuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.BindPermAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthSessionIdList) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.ConnType != 0 {
		n += 1 + sovSessionpb(uint64(m.ConnType))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	if len(m.SessionIdList) > 0 {
		l = 0
		for _, e := range m.SessionIdList {
			l += sovSessionpb(uint64(e))
		}
		n += 1 + sovSessionpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthId) Size() (n int) {
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionClientData) Size() (n int) {
	var l int
	_ = l
	l = len(m.ServerId)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	l = len(m.ClientIp)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.ConnType != 0 {
		n += 1 + sovSessionpb(uint64(m.ConnType))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	if m.QuickAck != 0 {
		n += 1 + sovSessionpb(uint64(m.QuickAck))
	}
	if m.SessionId != 0 {
		n += 1 + sovSessionpb(uint64(m.SessionId))
	}
	if m.Salt != 0 {
		n += 1 + sovSessionpb(uint64(m.Salt))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionClientData2) Size() (n int) {
	var l int
	_ = l
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.QuickAck != 0 {
		n += 1 + sovSessionpb(uint64(m.QuickAck))
	}
	if m.SessionId != 0 {
		n += 1 + sovSessionpb(uint64(m.SessionId))
	}
	if m.Salt != 0 {
		n += 1 + sovSessionpb(uint64(m.Salt))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SessionData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthKeyInfo) Size() (n int) {
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.AuthKeyType != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyType))
	}
	if m.PermAuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.PermAuthKeyId))
	}
	if m.TempAuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.TempAuthKeyId))
	}
	if m.MediaTempAuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.MediaTempAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthKeySalts) Size() (n int) {
	var l int
	_ = l
	if m.AuthKey != nil {
		l = m.AuthKey.Size()
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.FutureSalt != nil {
		l = m.FutureSalt.Size()
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushUpdatesData) Size() (n int) {
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	if m.Notification {
		n += 2
	}
	if m.Updates != nil {
		l = m.Updates.Size()
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushSessionUpdatesData) Size() (n int) {
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	if m.SessionId != 0 {
		n += 1 + sovSessionpb(uint64(m.SessionId))
	}
	if m.Updates != nil {
		l = m.Updates.Size()
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PushRpcResultData) Size() (n int) {
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovSessionpb(uint64(m.AuthKeyId))
	}
	if m.SessionId != 0 {
		n += 1 + sovSessionpb(uint64(m.SessionId))
	}
	if m.ClientReqMsgId != 0 {
		n += 1 + sovSessionpb(uint64(m.ClientReqMsgId))
	}
	l = len(m.RpcResultData)
	if l > 0 {
		n += 1 + l + sovSessionpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSessionpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSessionpb(x uint64) (n int) {
	return sovSessionpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientKeyId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientKeyId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientKeyId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			m.KeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermKeyId", wireType)
			}
			m.PermKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempKeyId", wireType)
			}
			m.TempKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaAuthKeyId", wireType)
			}
			m.MediaAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientConnData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientConnData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientConnData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientConnId", wireType)
			}
			m.ClientConnId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientConnId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnType", wireType)
			}
			m.ConnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeyId == nil {
				m.KeyId = &ClientKeyId{}
			}
			if err := m.KeyId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionClientEvent2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionClientEvent2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionClientEvent2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conn == nil {
				m.Conn = &ClientConnData{}
			}
			if err := m.Conn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionClientEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionClientEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionClientEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnType", wireType)
			}
			m.ConnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionRedirect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionRedirect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionRedirect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Redirect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Redirect = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindPermAuthKeyId", wireType)
			}
			m.BindPermAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindPermAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthSessionIdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthSessionIdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthSessionIdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnType", wireType)
			}
			m.ConnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSessionpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SessionIdList = append(m.SessionIdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSessionpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSessionpb
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSessionpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SessionIdList = append(m.SessionIdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionIdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionClientData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionClientData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionClientData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnType", wireType)
			}
			m.ConnType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuickAck", wireType)
			}
			m.QuickAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuickAck |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionClientData2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionClientData2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionClientData2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conn == nil {
				m.Conn = &ClientConnData{}
			}
			if err := m.Conn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuickAck", wireType)
			}
			m.QuickAck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuickAck |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SessionData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SessionData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SessionData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyType", wireType)
			}
			m.AuthKeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermAuthKeyId", wireType)
			}
			m.PermAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempAuthKeyId", wireType)
			}
			m.TempAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaTempAuthKeyId", wireType)
			}
			m.MediaTempAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaTempAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthKeySalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthKeySalts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthKeySalts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthKey == nil {
				m.AuthKey = &AuthKeyInfo{}
			}
			if err := m.AuthKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureSalt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FutureSalt == nil {
				m.FutureSalt = &mtproto.FutureSalt{}
			}
			if err := m.FutureSalt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushUpdatesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushUpdatesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushUpdatesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Notification = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Updates == nil {
				m.Updates = &mtproto.Updates{}
			}
			if err := m.Updates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushSessionUpdatesData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushSessionUpdatesData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushSessionUpdatesData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Updates == nil {
				m.Updates = &mtproto.Updates{}
			}
			if err := m.Updates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PushRpcResultData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PushRpcResultData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PushRpcResultData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientReqMsgId", wireType)
			}
			m.ClientReqMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientReqMsgId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcResultData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSessionpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RpcResultData = append(m.RpcResultData[:0], dAtA[iNdEx:postIndex]...)
			if m.RpcResultData == nil {
				m.RpcResultData = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSessionpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSessionpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSessionpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSessionpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSessionpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSessionpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSessionpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSessionpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSessionpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSessionpb   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("sessionpb.proto", fileDescriptor_sessionpb_f41fee5d2690f54f) }

var fileDescriptor_sessionpb_f41fee5d2690f54f = []byte{
	// 1133 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0x1b, 0x45,
	0x1c, 0xef, 0xc6, 0x76, 0x6c, 0xff, 0xd7, 0x4e, 0xea, 0x69, 0x1a, 0x1c, 0xb7, 0x35, 0x61, 0x85,
	0x68, 0x8a, 0x14, 0x1b, 0x5c, 0xb8, 0x80, 0x44, 0x95, 0xba, 0x41, 0xb5, 0xa0, 0x52, 0xb4, 0x29,
	0x17, 0x2e, 0xab, 0xf1, 0xee, 0x38, 0x5e, 0x79, 0xbd, 0xbb, 0x99, 0x99, 0x2d, 0xf2, 0x11, 0xf1,
	0x0c, 0x3c, 0x02, 0x17, 0x24, 0xde, 0x81, 0x23, 0x37, 0x78, 0x01, 0x24, 0xc8, 0x13, 0x20, 0xc4,
	0x03, 0xa0, 0x99, 0x9d, 0x5d, 0xef, 0x47, 0x92, 0x2a, 0x88, 0xde, 0x76, 0xfe, 0x1f, 0xbf, 0xf9,
	0xfd, 0x3f, 0x67, 0x61, 0x9b, 0x11, 0xc6, 0xdc, 0xc0, 0x0f, 0xa7, 0x83, 0x90, 0x06, 0x3c, 0x40,
	0xcd, 0x54, 0xd0, 0x3b, 0x3c, 0x73, 0xf9, 0x3c, 0x9a, 0x0e, 0xec, 0x60, 0x39, 0x3c, 0x0b, 0xce,
	0x82, 0xa1, 0xb4, 0x98, 0x46, 0x33, 0x79, 0x92, 0x07, 0xf9, 0x15, 0x7b, 0xf6, 0x7a, 0xcc, 0x9e,
	0x93, 0x25, 0x1e, 0x70, 0x6f, 0x60, 0x07, 0x94, 0x58, 0x7c, 0x15, 0x12, 0xa6, 0x74, 0x3b, 0x6b,
	0x1d, 0x5b, 0xf9, 0xb6, 0x92, 0xee, 0xad, 0xa5, 0x9c, 0x62, 0x9f, 0x85, 0x01, 0xe5, 0xb1, 0xca,
	0xf8, 0x51, 0x03, 0x7d, 0xec, 0xb9, 0xc4, 0xe7, 0x5f, 0x90, 0xd5, 0xc4, 0x41, 0x77, 0x61, 0x73,
	0x41, 0x56, 0x96, 0xeb, 0x74, 0xb5, 0x7d, 0xed, 0xa0, 0x62, 0xd6, 0x16, 0x52, 0xbc, 0x07, 0x0d,
	0x21, 0x16, 0x57, 0x75, 0x37, 0xf6, 0xb5, 0x83, 0x9a, 0x59, 0x5f, 0x90, 0xd5, 0xcb, 0x55, 0x48,
	0x50, 0x1f, 0xf4, 0x90, 0xd0, 0xa5, 0xa5, 0xdc, 0x2a, 0xd2, 0xad, 0x29, 0x44, 0x31, 0x62, 0x1f,
	0x74, 0x4e, 0x96, 0x61, 0xa2, 0xaf, 0xc6, 0x7a, 0x21, 0x8a, 0xf5, 0x8f, 0xa0, 0xb3, 0x24, 0x8e,
	0x8b, 0x2d, 0x1c, 0xf1, 0x79, 0x62, 0x55, 0x93, 0x56, 0x5b, 0x52, 0x71, 0x14, 0xf1, 0xb9, 0x34,
	0x35, 0x7e, 0xd6, 0x60, 0x2b, 0x26, 0x3b, 0x0e, 0x7c, 0xff, 0x19, 0xe6, 0x18, 0xdd, 0x83, 0x26,
	0x23, 0xf4, 0x15, 0xa1, 0x09, 0xe5, 0xa6, 0xd9, 0x88, 0x05, 0x13, 0x07, 0xbd, 0x0b, 0x5b, 0xb6,
	0x34, 0xb7, 0xec, 0xc0, 0xf7, 0x85, 0xc5, 0x86, 0xc4, 0x6d, 0xd9, 0x29, 0xc8, 0xc4, 0x11, 0x10,
	0x52, 0x2d, 0x83, 0xab, 0xc8, 0xe0, 0x1a, 0x42, 0x20, 0xa3, 0x7b, 0x1b, 0x74, 0x05, 0x81, 0x1d,
	0x87, 0x4a, 0xf6, 0x4d, 0x13, 0x62, 0xd1, 0x91, 0xe3, 0x50, 0x74, 0x98, 0x26, 0x4c, 0x70, 0xd6,
	0x47, 0xbb, 0x83, 0x75, 0xa5, 0x33, 0x89, 0x55, 0x89, 0x34, 0x6c, 0xb8, 0x73, 0x1a, 0xeb, 0x63,
	0xe5, 0xf1, 0x2b, 0xe2, 0xf3, 0x11, 0x3a, 0x84, 0xaa, 0xb8, 0x52, 0x46, 0xa0, 0x8f, 0xf6, 0x4a,
	0x18, 0x49, 0xbc, 0xa6, 0x34, 0x43, 0x0f, 0x00, 0x94, 0xc5, 0x3a, 0xa8, 0xa4, 0xa1, 0x26, 0x8e,
	0x28, 0x2a, 0x2a, 0xdf, 0x72, 0x7d, 0xae, 0x72, 0x59, 0xd8, 0x28, 0x64, 0xa1, 0x0f, 0x7a, 0xb6,
	0x3a, 0xaa, 0xc6, 0x38, 0x29, 0x4c, 0x81, 0x4f, 0xb5, 0xc0, 0x47, 0x62, 0xc7, 0x49, 0x74, 0x43,
	0x99, 0xa6, 0xa6, 0xd9, 0x88, 0x05, 0x93, 0xd0, 0xb0, 0x60, 0x5b, 0x71, 0x35, 0x89, 0xe3, 0x52,
	0x62, 0x73, 0xd4, 0x83, 0x06, 0x55, 0xdf, 0x92, 0x67, 0xc3, 0x4c, 0xcf, 0xe8, 0x03, 0xb8, 0x3b,
	0x75, 0x7d, 0xc7, 0x92, 0x3d, 0x97, 0x25, 0x15, 0x67, 0xa1, 0x23, 0x94, 0x27, 0x84, 0x2e, 0xd7,
	0x5d, 0xf3, 0xbd, 0x06, 0x1d, 0x71, 0x3a, 0x4d, 0xf8, 0x7c, 0xe9, 0xb2, 0x37, 0x99, 0x8c, 0xf7,
	0xd2, 0x61, 0xb7, 0x5c, 0xc7, 0xf2, 0x5c, 0xc6, 0xbb, 0xd5, 0xfd, 0xca, 0x41, 0xcd, 0x6c, 0xb3,
	0x2c, 0x03, 0xe3, 0x00, 0x36, 0x05, 0xad, 0x78, 0x44, 0xae, 0x43, 0x34, 0xfe, 0xd1, 0xa0, 0x93,
	0xab, 0xe7, 0xeb, 0x5b, 0x3f, 0x97, 0xf2, 0x4a, 0x3e, 0xe5, 0xf9, 0xf0, 0xaa, 0xd7, 0x87, 0x57,
	0x2b, 0x86, 0x77, 0x0f, 0x9a, 0xe7, 0x91, 0x6b, 0x2f, 0x2c, 0x6c, 0x2f, 0xba, 0x9b, 0xb1, 0xb3,
	0x14, 0x1c, 0xd9, 0x8b, 0x42, 0x23, 0xd4, 0x8b, 0x8d, 0x80, 0xa0, 0xca, 0xb0, 0xc7, 0xbb, 0x0d,
	0xa9, 0x90, 0xdf, 0xa8, 0x0b, 0xf5, 0x10, 0xaf, 0xbc, 0x00, 0x3b, 0xdd, 0xe6, 0xbe, 0x76, 0xd0,
	0x32, 0x93, 0xa3, 0xf1, 0x53, 0xb1, 0x8d, 0x45, 0xd8, 0x37, 0x9e, 0x95, 0x1c, 0xdf, 0x8d, 0x6b,
	0xf9, 0x56, 0xae, 0xe2, 0x5b, 0xbd, 0x9c, 0x6f, 0x2d, 0xcf, 0xf7, 0x21, 0xe8, 0x8a, 0xae, 0xac,
	0x4f, 0xc6, 0xb0, 0x92, 0x37, 0xfc, 0x5b, 0x03, 0x3d, 0xe9, 0x4f, 0x7f, 0x16, 0xbc, 0xb6, 0xa3,
	0xf6, 0xa0, 0x91, 0xe8, 0x25, 0x95, 0x96, 0x59, 0x57, 0x4a, 0x64, 0x40, 0x3b, 0x75, 0x95, 0xe5,
	0xac, 0xc9, 0x08, 0x75, 0xa5, 0x97, 0x15, 0x7d, 0x08, 0xb7, 0x4b, 0xd3, 0xb2, 0x29, 0xef, 0x68,
	0x87, 0xd9, 0x49, 0x11, 0x86, 0x72, 0x55, 0x67, 0x0d, 0xe3, 0x1a, 0xb6, 0x85, 0x7c, 0x6d, 0x38,
	0x82, 0xdd, 0x78, 0x67, 0x97, 0xcc, 0xe3, 0xca, 0x22, 0xa9, 0x7d, 0x99, 0xf5, 0x31, 0xbe, 0x81,
	0x96, 0x3a, 0x9c, 0x62, 0x8f, 0x33, 0xf4, 0x61, 0x26, 0xa8, 0x8d, 0xd2, 0xea, 0xcc, 0xa4, 0x67,
	0x1d, 0xec, 0x47, 0xa0, 0xcf, 0x22, 0x1e, 0x51, 0x62, 0xc9, 0xaa, 0x54, 0xa4, 0xd7, 0x9d, 0xc1,
	0x92, 0xcb, 0xb7, 0x6c, 0xf0, 0xb9, 0xd4, 0x09, 0x74, 0x13, 0x66, 0xe9, 0xb7, 0xf1, 0xad, 0x06,
	0xdb, 0x27, 0x11, 0x9b, 0x7f, 0x15, 0x3a, 0x98, 0x13, 0x26, 0x6b, 0x53, 0xc8, 0xb8, 0x56, 0xcc,
	0xb8, 0x01, 0x2d, 0x3f, 0xe0, 0xee, 0xcc, 0xb5, 0x31, 0x77, 0x03, 0x5f, 0x12, 0x6c, 0x98, 0x39,
	0x19, 0x7a, 0x1f, 0xea, 0x51, 0x0c, 0xa9, 0x98, 0xdc, 0x4e, 0x99, 0xa8, 0xab, 0xcc, 0xc4, 0xc0,
	0xf8, 0x4e, 0x83, 0x5d, 0xc1, 0x41, 0xf5, 0xc7, 0x4d, 0xa8, 0x5c, 0xbf, 0xeb, 0x6f, 0xc4, 0xe2,
	0x07, 0x0d, 0x3a, 0x82, 0x85, 0x19, 0xda, 0x26, 0x61, 0x91, 0xc7, 0xff, 0x0f, 0x02, 0x8f, 0xa0,
	0xa3, 0x36, 0x0d, 0x25, 0xe7, 0xd6, 0x92, 0x9d, 0xad, 0x5b, 0x58, 0xbd, 0xbe, 0x26, 0x39, 0x7f,
	0xc1, 0xce, 0xe2, 0xcd, 0x48, 0x43, 0xdb, 0xa2, 0xf2, 0x6e, 0xcb, 0xc1, 0x1c, 0xab, 0x76, 0x6e,
	0xd3, 0x2c, 0xa3, 0xd1, 0xef, 0x55, 0x00, 0xf3, 0x64, 0xac, 0x92, 0x85, 0x9e, 0x40, 0x7b, 0x4c,
	0x09, 0xe6, 0x24, 0x11, 0x3c, 0xc8, 0x34, 0x4a, 0xf9, 0x9d, 0xeb, 0xb5, 0xd3, 0x0c, 0x3c, 0x0d,
	0x02, 0xcf, 0xb8, 0x85, 0x3e, 0x83, 0xd6, 0xd8, 0x0b, 0xd8, 0x7f, 0xf6, 0x3f, 0x86, 0x9d, 0x53,
	0xe2, 0x3b, 0x47, 0xe2, 0x97, 0x2a, 0x3b, 0xe1, 0xf7, 0xaf, 0xc2, 0x11, 0xda, 0x32, 0xcc, 0x0b,
	0xf1, 0xf6, 0xfb, 0xce, 0xe9, 0x8d, 0x50, 0x76, 0xcb, 0x5a, 0x21, 0x37, 0x6e, 0xa1, 0x4f, 0xa1,
	0xf9, 0x9c, 0x60, 0xca, 0xa7, 0x04, 0xf3, 0x1b, 0x87, 0xf4, 0x31, 0x6c, 0x3f, 0x23, 0x8c, 0xd3,
	0x60, 0xa5, 0xac, 0x19, 0xea, 0x14, 0xc6, 0x6f, 0xe2, 0x94, 0xdd, 0x9e, 0xc0, 0xd6, 0x64, 0x29,
	0x7e, 0x1f, 0x53, 0xaf, 0xfb, 0x05, 0xaf, 0xdc, 0x2b, 0x5b, 0x06, 0x18, 0xc3, 0x4e, 0xd2, 0x4c,
	0xe7, 0x11, 0xa1, 0x2b, 0x35, 0xe7, 0x97, 0x5d, 0x7e, 0xc5, 0x3a, 0x90, 0xf5, 0x44, 0x09, 0x08,
	0x23, 0x3c, 0x81, 0x78, 0xab, 0x6c, 0x2f, 0x37, 0x4d, 0x89, 0xc4, 0xe8, 0x57, 0x0d, 0xea, 0xe6,
	0xc9, 0x58, 0x8c, 0x02, 0xfa, 0x04, 0xf4, 0xcc, 0x72, 0x40, 0xbd, 0x0c, 0x48, 0x61, 0x69, 0x5c,
	0xd6, 0x57, 0xed, 0xdc, 0x38, 0xe5, 0x92, 0x51, 0x1a, 0xb4, 0xb2, 0xff, 0x73, 0x40, 0xe5, 0xa5,
	0x80, 0xde, 0x29, 0x80, 0x94, 0x77, 0x46, 0x09, 0xe9, 0xe9, 0xf1, 0x5f, 0x7f, 0xf6, 0xb5, 0x5f,
	0x2e, 0xfa, 0xda, 0x6f, 0x17, 0x7d, 0xed, 0x8f, 0x8b, 0xbe, 0xf6, 0xf5, 0x63, 0x9f, 0x4c, 0x23,
	0x0f, 0x0f, 0xec, 0x39, 0xe6, 0x43, 0xdb, 0x8b, 0x18, 0x27, 0x74, 0x88, 0xc3, 0x70, 0xe8, 0xfa,
	0x9c, 0xd0, 0x19, 0xb6, 0xc9, 0x50, 0x5d, 0x33, 0x4c, 0xaf, 0x9b, 0x6e, 0x4a, 0xd0, 0xc7, 0xff,
	0x06, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x0c, 0xa6, 0xe9, 0xae, 0x0c, 0x00, 0x00,
}
