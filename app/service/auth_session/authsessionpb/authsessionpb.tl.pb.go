// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authsessionpb.tl.proto

package authsessionpb // import "open.chat/app/service/auth_session/authsessionpb"

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import mtproto "open.chat/mtproto"

import strings "strings"
import reflect "reflect"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN TLConstructor = 0
)

var TLConstructor_name = map[int32]string{
	0: "CRC32_UNKNOWN",
}
var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN": 0,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}
func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{0}
}

// --------------------------------------------------------------------------------------------
// authKeyInfo flags:# auth_key_id:long auth_key:bytes future_salt:flags.0?FutureSalt= AuthKeyInfo;
//
// AuthKeyInfo <--
//   - TL_authKeyInfo
type AuthKeyInfo struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	AuthKey              []byte        `protobuf:"bytes,4,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	AuthKeyType          int32         `protobuf:"varint,5,opt,name=auth_key_type,json=authKeyType,proto3" json:"auth_key_type,omitempty"`
	PermAuthKeyId        int64         `protobuf:"varint,6,opt,name=perm_auth_key_id,json=permAuthKeyId,proto3" json:"perm_auth_key_id,omitempty"`
	TempAuthKeyId        int64         `protobuf:"varint,7,opt,name=temp_auth_key_id,json=tempAuthKeyId,proto3" json:"temp_auth_key_id,omitempty"`
	MediaTempAuthKeyId   int64         `protobuf:"varint,8,opt,name=media_temp_auth_key_id,json=mediaTempAuthKeyId,proto3" json:"media_temp_auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AuthKeyInfo) Reset()         { *m = AuthKeyInfo{} }
func (m *AuthKeyInfo) String() string { return proto.CompactTextString(m) }
func (*AuthKeyInfo) ProtoMessage()    {}
func (*AuthKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{0}
}
func (m *AuthKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *AuthKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthKeyInfo.Merge(dst, src)
}
func (m *AuthKeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *AuthKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthKeyInfo proto.InternalMessageInfo

func (m *AuthKeyInfo) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *AuthKeyInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *AuthKeyInfo) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *AuthKeyInfo) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *AuthKeyInfo) GetAuthKeyType() int32 {
	if m != nil {
		return m.AuthKeyType
	}
	return 0
}

func (m *AuthKeyInfo) GetPermAuthKeyId() int64 {
	if m != nil {
		return m.PermAuthKeyId
	}
	return 0
}

func (m *AuthKeyInfo) GetTempAuthKeyId() int64 {
	if m != nil {
		return m.TempAuthKeyId
	}
	return 0
}

func (m *AuthKeyInfo) GetMediaTempAuthKeyId() int64 {
	if m != nil {
		return m.MediaTempAuthKeyId
	}
	return 0
}

// authKeyInfo flags:# auth_key_id:long auth_key:bytes future_salt:flags.0?FutureSalt= AuthKeyInfo;
type TLAuthKeyInfo struct {
	Data2                *AuthKeyInfo `protobuf:"bytes,1,opt,name=data2" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TLAuthKeyInfo) Reset()         { *m = TLAuthKeyInfo{} }
func (m *TLAuthKeyInfo) String() string { return proto.CompactTextString(m) }
func (*TLAuthKeyInfo) ProtoMessage()    {}
func (*TLAuthKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{1}
}
func (m *TLAuthKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLAuthKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthKeyInfo.Merge(dst, src)
}
func (m *TLAuthKeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthKeyInfo proto.InternalMessageInfo

func (m *TLAuthKeyInfo) GetData2() *AuthKeyInfo {
	if m != nil {
		return m.Data2
	}
	return nil
}

// --------------------------------------------------------------------------------------------
// clientSessionInfo auth_key_id:long ip:string layer:int api_id:int device_model:string system_version:string app_version:string system_lang_code:string lang_pack:string lang_code:string = ClientSession;
//
// ClientSession <--
//   - TL_clientSessionInfo
type ClientSession struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Ip                   string        `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	Layer                int32         `protobuf:"varint,5,opt,name=layer,proto3" json:"layer,omitempty"`
	ApiId                int32         `protobuf:"varint,6,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel          string        `protobuf:"bytes,7,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion        string        `protobuf:"bytes,8,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion           string        `protobuf:"bytes,9,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	SystemLangCode       string        `protobuf:"bytes,10,opt,name=system_lang_code,json=systemLangCode,proto3" json:"system_lang_code,omitempty"`
	LangPack             string        `protobuf:"bytes,11,opt,name=lang_pack,json=langPack,proto3" json:"lang_pack,omitempty"`
	LangCode             string        `protobuf:"bytes,12,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Proxy                string        `protobuf:"bytes,13,opt,name=proxy,proto3" json:"proxy,omitempty"`
	Params               string        `protobuf:"bytes,14,opt,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ClientSession) Reset()         { *m = ClientSession{} }
func (m *ClientSession) String() string { return proto.CompactTextString(m) }
func (*ClientSession) ProtoMessage()    {}
func (*ClientSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{2}
}
func (m *ClientSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ClientSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSession.Merge(dst, src)
}
func (m *ClientSession) XXX_Size() int {
	return m.Size()
}
func (m *ClientSession) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSession.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSession proto.InternalMessageInfo

func (m *ClientSession) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *ClientSession) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *ClientSession) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *ClientSession) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ClientSession) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *ClientSession) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *ClientSession) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *ClientSession) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *ClientSession) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *ClientSession) GetSystemLangCode() string {
	if m != nil {
		return m.SystemLangCode
	}
	return ""
}

func (m *ClientSession) GetLangPack() string {
	if m != nil {
		return m.LangPack
	}
	return ""
}

func (m *ClientSession) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *ClientSession) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *ClientSession) GetParams() string {
	if m != nil {
		return m.Params
	}
	return ""
}

// clientSessionInfo auth_key_id:long ip:string layer:int api_id:int device_model:string system_version:string app_version:string system_lang_code:string lang_pack:string lang_code:string = ClientSession;
type TLClientSessionInfo struct {
	Data2                *ClientSession `protobuf:"bytes,1,opt,name=data2" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLClientSessionInfo) Reset()         { *m = TLClientSessionInfo{} }
func (m *TLClientSessionInfo) String() string { return proto.CompactTextString(m) }
func (*TLClientSessionInfo) ProtoMessage()    {}
func (*TLClientSessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{3}
}
func (m *TLClientSessionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLClientSessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLClientSessionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLClientSessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLClientSessionInfo.Merge(dst, src)
}
func (m *TLClientSessionInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLClientSessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLClientSessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLClientSessionInfo proto.InternalMessageInfo

func (m *TLClientSessionInfo) GetData2() *ClientSession {
	if m != nil {
		return m.Data2
	}
	return nil
}

// --------------------------------------------------------------------------------------------
// session.setClientSessionInfo session:ClientSession = Bool;
type TLSessionSetClientSessionInfo struct {
	Constructor          TLConstructor  `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	Session              *ClientSession `protobuf:"bytes,3,opt,name=session" json:"session,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLSessionSetClientSessionInfo) Reset()         { *m = TLSessionSetClientSessionInfo{} }
func (m *TLSessionSetClientSessionInfo) String() string { return proto.CompactTextString(m) }
func (*TLSessionSetClientSessionInfo) ProtoMessage()    {}
func (*TLSessionSetClientSessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{4}
}
func (m *TLSessionSetClientSessionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionSetClientSessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionSetClientSessionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionSetClientSessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionSetClientSessionInfo.Merge(dst, src)
}
func (m *TLSessionSetClientSessionInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionSetClientSessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionSetClientSessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionSetClientSessionInfo proto.InternalMessageInfo

func (m *TLSessionSetClientSessionInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionSetClientSessionInfo) GetSession() *ClientSession {
	if m != nil {
		return m.Session
	}
	return nil
}

// --------------------------------------------------------------------------------------------
// session.getAuthorizations user_id:int exclude_auth_keyId:long = account.Authorizations;
type TLSessionGetAuthorization struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_keyId,json=authKeyId,proto3" json:"auth_keyId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionGetAuthorization) Reset()         { *m = TLSessionGetAuthorization{} }
func (m *TLSessionGetAuthorization) String() string { return proto.CompactTextString(m) }
func (*TLSessionGetAuthorization) ProtoMessage()    {}
func (*TLSessionGetAuthorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{5}
}
func (m *TLSessionGetAuthorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionGetAuthorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionGetAuthorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionGetAuthorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionGetAuthorization.Merge(dst, src)
}
func (m *TLSessionGetAuthorization) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionGetAuthorization) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionGetAuthorization.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionGetAuthorization proto.InternalMessageInfo

func (m *TLSessionGetAuthorization) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionGetAuthorization) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

type TLSessionGetAuthorizations struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	UserId               int32         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ExcludeAuthKeyId     int64         `protobuf:"varint,4,opt,name=exclude_auth_keyId,json=excludeAuthKeyId,proto3" json:"exclude_auth_keyId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionGetAuthorizations) Reset()         { *m = TLSessionGetAuthorizations{} }
func (m *TLSessionGetAuthorizations) String() string { return proto.CompactTextString(m) }
func (*TLSessionGetAuthorizations) ProtoMessage()    {}
func (*TLSessionGetAuthorizations) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{6}
}
func (m *TLSessionGetAuthorizations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionGetAuthorizations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionGetAuthorizations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionGetAuthorizations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionGetAuthorizations.Merge(dst, src)
}
func (m *TLSessionGetAuthorizations) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionGetAuthorizations) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionGetAuthorizations.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionGetAuthorizations proto.InternalMessageInfo

func (m *TLSessionGetAuthorizations) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionGetAuthorizations) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLSessionGetAuthorizations) GetExcludeAuthKeyId() int64 {
	if m != nil {
		return m.ExcludeAuthKeyId
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.resetAuthorization user_id:int hash:long = Int64;
type TLSessionResetAuthorization struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	UserId               int32         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Hash                 int64         `protobuf:"varint,5,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionResetAuthorization) Reset()         { *m = TLSessionResetAuthorization{} }
func (m *TLSessionResetAuthorization) String() string { return proto.CompactTextString(m) }
func (*TLSessionResetAuthorization) ProtoMessage()    {}
func (*TLSessionResetAuthorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{7}
}
func (m *TLSessionResetAuthorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionResetAuthorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionResetAuthorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionResetAuthorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionResetAuthorization.Merge(dst, src)
}
func (m *TLSessionResetAuthorization) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionResetAuthorization) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionResetAuthorization.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionResetAuthorization proto.InternalMessageInfo

func (m *TLSessionResetAuthorization) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionResetAuthorization) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLSessionResetAuthorization) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLSessionResetAuthorization) GetHash() int64 {
	if m != nil {
		return m.Hash
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.getLayer auth_key_id:long = Int32;
type TLSessionGetLayer struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionGetLayer) Reset()         { *m = TLSessionGetLayer{} }
func (m *TLSessionGetLayer) String() string { return proto.CompactTextString(m) }
func (*TLSessionGetLayer) ProtoMessage()    {}
func (*TLSessionGetLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{8}
}
func (m *TLSessionGetLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionGetLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionGetLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionGetLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionGetLayer.Merge(dst, src)
}
func (m *TLSessionGetLayer) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionGetLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionGetLayer.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionGetLayer proto.InternalMessageInfo

func (m *TLSessionGetLayer) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionGetLayer) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.getLangCode auth_key_id:long = String;
type TLSessionGetLangCode struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionGetLangCode) Reset()         { *m = TLSessionGetLangCode{} }
func (m *TLSessionGetLangCode) String() string { return proto.CompactTextString(m) }
func (*TLSessionGetLangCode) ProtoMessage()    {}
func (*TLSessionGetLangCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{9}
}
func (m *TLSessionGetLangCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionGetLangCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionGetLangCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionGetLangCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionGetLangCode.Merge(dst, src)
}
func (m *TLSessionGetLangCode) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionGetLangCode) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionGetLangCode.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionGetLangCode proto.InternalMessageInfo

func (m *TLSessionGetLangCode) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionGetLangCode) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.getUserId auth_key_id:long = Int32;
type TLSessionGetUserId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionGetUserId) Reset()         { *m = TLSessionGetUserId{} }
func (m *TLSessionGetUserId) String() string { return proto.CompactTextString(m) }
func (*TLSessionGetUserId) ProtoMessage()    {}
func (*TLSessionGetUserId) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{10}
}
func (m *TLSessionGetUserId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionGetUserId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionGetUserId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionGetUserId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionGetUserId.Merge(dst, src)
}
func (m *TLSessionGetUserId) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionGetUserId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionGetUserId.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionGetUserId proto.InternalMessageInfo

func (m *TLSessionGetUserId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionGetUserId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.getPushSessionId user_id:int auth_key_id:long token_type:int = Int64;
type TLSessionGetPushSessionId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	UserId               int32         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	TokenType            int32         `protobuf:"varint,5,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionGetPushSessionId) Reset()         { *m = TLSessionGetPushSessionId{} }
func (m *TLSessionGetPushSessionId) String() string { return proto.CompactTextString(m) }
func (*TLSessionGetPushSessionId) ProtoMessage()    {}
func (*TLSessionGetPushSessionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{11}
}
func (m *TLSessionGetPushSessionId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionGetPushSessionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionGetPushSessionId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionGetPushSessionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionGetPushSessionId.Merge(dst, src)
}
func (m *TLSessionGetPushSessionId) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionGetPushSessionId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionGetPushSessionId.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionGetPushSessionId proto.InternalMessageInfo

func (m *TLSessionGetPushSessionId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionGetPushSessionId) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLSessionGetPushSessionId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLSessionGetPushSessionId) GetTokenType() int32 {
	if m != nil {
		return m.TokenType
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.getFutureSalts auth_key_id:long num:int = FutureSalts;
type TLSessionGetFutureSalts struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Num                  int32         `protobuf:"varint,4,opt,name=num,proto3" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionGetFutureSalts) Reset()         { *m = TLSessionGetFutureSalts{} }
func (m *TLSessionGetFutureSalts) String() string { return proto.CompactTextString(m) }
func (*TLSessionGetFutureSalts) ProtoMessage()    {}
func (*TLSessionGetFutureSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{12}
}
func (m *TLSessionGetFutureSalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionGetFutureSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionGetFutureSalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionGetFutureSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionGetFutureSalts.Merge(dst, src)
}
func (m *TLSessionGetFutureSalts) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionGetFutureSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionGetFutureSalts.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionGetFutureSalts proto.InternalMessageInfo

func (m *TLSessionGetFutureSalts) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionGetFutureSalts) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLSessionGetFutureSalts) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.queryAuthKey auth_key_id:long = AuthKeyInfo;
type TLSessionQueryAuthKey struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionQueryAuthKey) Reset()         { *m = TLSessionQueryAuthKey{} }
func (m *TLSessionQueryAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLSessionQueryAuthKey) ProtoMessage()    {}
func (*TLSessionQueryAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{13}
}
func (m *TLSessionQueryAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionQueryAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionQueryAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionQueryAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionQueryAuthKey.Merge(dst, src)
}
func (m *TLSessionQueryAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionQueryAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionQueryAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionQueryAuthKey proto.InternalMessageInfo

func (m *TLSessionQueryAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionQueryAuthKey) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.setAuthKey auth_key:AuthKeyInfo = Bool;
type TLSessionSetAuthKey struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKey              *AuthKeyInfo        `protobuf:"bytes,2,opt,name=auth_key,json=authKey" json:"auth_key,omitempty"`
	FutureSalt           *mtproto.FutureSalt `protobuf:"bytes,3,opt,name=future_salt,json=futureSalt" json:"future_salt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLSessionSetAuthKey) Reset()         { *m = TLSessionSetAuthKey{} }
func (m *TLSessionSetAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLSessionSetAuthKey) ProtoMessage()    {}
func (*TLSessionSetAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{14}
}
func (m *TLSessionSetAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionSetAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionSetAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionSetAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionSetAuthKey.Merge(dst, src)
}
func (m *TLSessionSetAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionSetAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionSetAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionSetAuthKey proto.InternalMessageInfo

func (m *TLSessionSetAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionSetAuthKey) GetAuthKey() *AuthKeyInfo {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *TLSessionSetAuthKey) GetFutureSalt() *mtproto.FutureSalt {
	if m != nil {
		return m.FutureSalt
	}
	return nil
}

// --------------------------------------------------------------------------------------------
// session.bindAuthKeyUser auth_key_id:long user_id:int = Bool;
type TLSessionBindAuthKeyUser struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int32         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionBindAuthKeyUser) Reset()         { *m = TLSessionBindAuthKeyUser{} }
func (m *TLSessionBindAuthKeyUser) String() string { return proto.CompactTextString(m) }
func (*TLSessionBindAuthKeyUser) ProtoMessage()    {}
func (*TLSessionBindAuthKeyUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{15}
}
func (m *TLSessionBindAuthKeyUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionBindAuthKeyUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionBindAuthKeyUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionBindAuthKeyUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionBindAuthKeyUser.Merge(dst, src)
}
func (m *TLSessionBindAuthKeyUser) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionBindAuthKeyUser) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionBindAuthKeyUser.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionBindAuthKeyUser proto.InternalMessageInfo

func (m *TLSessionBindAuthKeyUser) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionBindAuthKeyUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLSessionBindAuthKeyUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// --------------------------------------------------------------------------------------------
// session.unbindAuthKeyUser auth_key_id:long user_id:int = Bool;
type TLSessionUnbindAuthKeyUser struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsessionpb.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int32         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLSessionUnbindAuthKeyUser) Reset()         { *m = TLSessionUnbindAuthKeyUser{} }
func (m *TLSessionUnbindAuthKeyUser) String() string { return proto.CompactTextString(m) }
func (*TLSessionUnbindAuthKeyUser) ProtoMessage()    {}
func (*TLSessionUnbindAuthKeyUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{16}
}
func (m *TLSessionUnbindAuthKeyUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLSessionUnbindAuthKeyUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLSessionUnbindAuthKeyUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TLSessionUnbindAuthKeyUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLSessionUnbindAuthKeyUser.Merge(dst, src)
}
func (m *TLSessionUnbindAuthKeyUser) XXX_Size() int {
	return m.Size()
}
func (m *TLSessionUnbindAuthKeyUser) XXX_DiscardUnknown() {
	xxx_messageInfo_TLSessionUnbindAuthKeyUser.DiscardUnknown(m)
}

var xxx_messageInfo_TLSessionUnbindAuthKeyUser proto.InternalMessageInfo

func (m *TLSessionUnbindAuthKeyUser) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLSessionUnbindAuthKeyUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLSessionUnbindAuthKeyUser) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type VectorLong struct {
	Datas                []int64  `protobuf:"varint,1,rep,packed,name=datas" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VectorLong) Reset()         { *m = VectorLong{} }
func (m *VectorLong) String() string { return proto.CompactTextString(m) }
func (*VectorLong) ProtoMessage()    {}
func (*VectorLong) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{17}
}
func (m *VectorLong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VectorLong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VectorLong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *VectorLong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VectorLong.Merge(dst, src)
}
func (m *VectorLong) XXX_Size() int {
	return m.Size()
}
func (m *VectorLong) XXX_DiscardUnknown() {
	xxx_messageInfo_VectorLong.DiscardUnknown(m)
}

var xxx_messageInfo_VectorLong proto.InternalMessageInfo

func (m *VectorLong) GetDatas() []int64 {
	if m != nil {
		return m.Datas
	}
	return nil
}

type KeyStateData struct {
	AuthKeyId            int64    `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int32    `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyState             int32    `protobuf:"varint,5,opt,name=key_state,json=keyState,proto3" json:"key_state,omitempty"`
	Layer                int32    `protobuf:"varint,7,opt,name=layer,proto3" json:"layer,omitempty"`
	ClientType           int32    `protobuf:"varint,6,opt,name=client_type,json=clientType,proto3" json:"client_type,omitempty"`
	AndroidPushSessionId int64    `protobuf:"varint,8,opt,name=android_push_session_id,json=androidPushSessionId,proto3" json:"android_push_session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyStateData) Reset()         { *m = KeyStateData{} }
func (m *KeyStateData) String() string { return proto.CompactTextString(m) }
func (*KeyStateData) ProtoMessage()    {}
func (*KeyStateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_authsessionpb_tl_5282a1203cd8149c, []int{18}
}
func (m *KeyStateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyStateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyStateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *KeyStateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyStateData.Merge(dst, src)
}
func (m *KeyStateData) XXX_Size() int {
	return m.Size()
}
func (m *KeyStateData) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyStateData.DiscardUnknown(m)
}

var xxx_messageInfo_KeyStateData proto.InternalMessageInfo

func (m *KeyStateData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *KeyStateData) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *KeyStateData) GetKeyState() int32 {
	if m != nil {
		return m.KeyState
	}
	return 0
}

func (m *KeyStateData) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *KeyStateData) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *KeyStateData) GetAndroidPushSessionId() int64 {
	if m != nil {
		return m.AndroidPushSessionId
	}
	return 0
}

func init() {
	proto.RegisterType((*AuthKeyInfo)(nil), "authsessionpb.AuthKeyInfo")
	proto.RegisterType((*TLAuthKeyInfo)(nil), "authsessionpb.TL_authKeyInfo")
	proto.RegisterType((*ClientSession)(nil), "authsessionpb.ClientSession")
	proto.RegisterType((*TLClientSessionInfo)(nil), "authsessionpb.TL_clientSessionInfo")
	proto.RegisterType((*TLSessionSetClientSessionInfo)(nil), "authsessionpb.TL_session_setClientSessionInfo")
	proto.RegisterType((*TLSessionGetAuthorization)(nil), "authsessionpb.TL_session_getAuthorization")
	proto.RegisterType((*TLSessionGetAuthorizations)(nil), "authsessionpb.TL_session_getAuthorizations")
	proto.RegisterType((*TLSessionResetAuthorization)(nil), "authsessionpb.TL_session_resetAuthorization")
	proto.RegisterType((*TLSessionGetLayer)(nil), "authsessionpb.TL_session_getLayer")
	proto.RegisterType((*TLSessionGetLangCode)(nil), "authsessionpb.TL_session_getLangCode")
	proto.RegisterType((*TLSessionGetUserId)(nil), "authsessionpb.TL_session_getUserId")
	proto.RegisterType((*TLSessionGetPushSessionId)(nil), "authsessionpb.TL_session_getPushSessionId")
	proto.RegisterType((*TLSessionGetFutureSalts)(nil), "authsessionpb.TL_session_getFutureSalts")
	proto.RegisterType((*TLSessionQueryAuthKey)(nil), "authsessionpb.TL_session_queryAuthKey")
	proto.RegisterType((*TLSessionSetAuthKey)(nil), "authsessionpb.TL_session_setAuthKey")
	proto.RegisterType((*TLSessionBindAuthKeyUser)(nil), "authsessionpb.TL_session_bindAuthKeyUser")
	proto.RegisterType((*TLSessionUnbindAuthKeyUser)(nil), "authsessionpb.TL_session_unbindAuthKeyUser")
	proto.RegisterType((*VectorLong)(nil), "authsessionpb.Vector_long")
	proto.RegisterType((*KeyStateData)(nil), "authsessionpb.KeyStateData")
	proto.RegisterEnum("authsessionpb.TLConstructor", TLConstructor_name, TLConstructor_value)
}
func (this *AuthKeyInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&authsessionpb.AuthKeyInfo{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "AuthKey: "+fmt.Sprintf("%#v", this.AuthKey)+",")
	s = append(s, "AuthKeyType: "+fmt.Sprintf("%#v", this.AuthKeyType)+",")
	s = append(s, "PermAuthKeyId: "+fmt.Sprintf("%#v", this.PermAuthKeyId)+",")
	s = append(s, "TempAuthKeyId: "+fmt.Sprintf("%#v", this.TempAuthKeyId)+",")
	s = append(s, "MediaTempAuthKeyId: "+fmt.Sprintf("%#v", this.MediaTempAuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthKeyInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsessionpb.TLAuthKeyInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClientSession) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&authsessionpb.ClientSession{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",")
	s = append(s, "ApiId: "+fmt.Sprintf("%#v", this.ApiId)+",")
	s = append(s, "DeviceModel: "+fmt.Sprintf("%#v", this.DeviceModel)+",")
	s = append(s, "SystemVersion: "+fmt.Sprintf("%#v", this.SystemVersion)+",")
	s = append(s, "AppVersion: "+fmt.Sprintf("%#v", this.AppVersion)+",")
	s = append(s, "SystemLangCode: "+fmt.Sprintf("%#v", this.SystemLangCode)+",")
	s = append(s, "LangPack: "+fmt.Sprintf("%#v", this.LangPack)+",")
	s = append(s, "LangCode: "+fmt.Sprintf("%#v", this.LangCode)+",")
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",")
	s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLClientSessionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsessionpb.TLClientSessionInfo{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionSetClientSessionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsessionpb.TLSessionSetClientSessionInfo{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	if this.Session != nil {
		s = append(s, "Session: "+fmt.Sprintf("%#v", this.Session)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionGetAuthorization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsessionpb.TLSessionGetAuthorization{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionGetAuthorizations) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsessionpb.TLSessionGetAuthorizations{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",")
	s = append(s, "ExcludeAuthKeyId: "+fmt.Sprintf("%#v", this.ExcludeAuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionResetAuthorization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsessionpb.TLSessionResetAuthorization{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionGetLayer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsessionpb.TLSessionGetLayer{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionGetLangCode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsessionpb.TLSessionGetLangCode{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionGetUserId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsessionpb.TLSessionGetUserId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionGetPushSessionId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsessionpb.TLSessionGetPushSessionId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "TokenType: "+fmt.Sprintf("%#v", this.TokenType)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionGetFutureSalts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsessionpb.TLSessionGetFutureSalts{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "Num: "+fmt.Sprintf("%#v", this.Num)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionQueryAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsessionpb.TLSessionQueryAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionSetAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsessionpb.TLSessionSetAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	if this.AuthKey != nil {
		s = append(s, "AuthKey: "+fmt.Sprintf("%#v", this.AuthKey)+",")
	}
	if this.FutureSalt != nil {
		s = append(s, "FutureSalt: "+fmt.Sprintf("%#v", this.FutureSalt)+",")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionBindAuthKeyUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsessionpb.TLSessionBindAuthKeyUser{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLSessionUnbindAuthKeyUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsessionpb.TLSessionUnbindAuthKeyUser{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VectorLong) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsessionpb.VectorLong{")
	s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *KeyStateData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&authsessionpb.KeyStateData{")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",")
	s = append(s, "KeyState: "+fmt.Sprintf("%#v", this.KeyState)+",")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",")
	s = append(s, "ClientType: "+fmt.Sprintf("%#v", this.ClientType)+",")
	s = append(s, "AndroidPushSessionId: "+fmt.Sprintf("%#v", this.AndroidPushSessionId)+",")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAuthsessionpbTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCSessionClient is the client API for RPCSession service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCSessionClient interface {
	// session.setClientSessionInfo session:ClientSession = Bool;
	SessionSetClientSessionInfo(ctx context.Context, in *TLSessionSetClientSessionInfo, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// session.getAuthorization auth_keyId:long = account.Authorizations;
	SessionGetAuthorization(ctx context.Context, in *TLSessionGetAuthorization, opts ...grpc.CallOption) (*mtproto.Authorization, error)
	// session.getAuthorizations user_id:int exclude_auth_keyId:long = account.Authorizations;
	SessionGetAuthorizations(ctx context.Context, in *TLSessionGetAuthorizations, opts ...grpc.CallOption) (*mtproto.Account_Authorizations, error)
	// session.resetAuthorization user_id:int hash:long = Int64;
	SessionResetAuthorization(ctx context.Context, in *TLSessionResetAuthorization, opts ...grpc.CallOption) (*VectorLong, error)
	// session.getLayer auth_key_id:long = Int32;
	SessionGetLayer(ctx context.Context, in *TLSessionGetLayer, opts ...grpc.CallOption) (*mtproto.Int32, error)
	// session.getLangCode auth_key_id:long = String;
	SessionGetLangCode(ctx context.Context, in *TLSessionGetLangCode, opts ...grpc.CallOption) (*mtproto.String, error)
	// session.getUserId auth_key_id:long = Int32;
	SessionGetUserId(ctx context.Context, in *TLSessionGetUserId, opts ...grpc.CallOption) (*mtproto.Int32, error)
	// session.getPushSessionId user_id:int auth_key_id:long token_type:int = Int64;
	SessionGetPushSessionId(ctx context.Context, in *TLSessionGetPushSessionId, opts ...grpc.CallOption) (*mtproto.Int64, error)
	// session.getFutureSalts auth_key_id:long num:int = FutureSalts;
	SessionGetFutureSalts(ctx context.Context, in *TLSessionGetFutureSalts, opts ...grpc.CallOption) (*mtproto.FutureSalts, error)
	// session.queryAuthKey auth_key_id:long = AuthKeyInfo;
	SessionQueryAuthKey(ctx context.Context, in *TLSessionQueryAuthKey, opts ...grpc.CallOption) (*AuthKeyInfo, error)
	// session.setAuthKey auth_key:AuthKeyInfo = Bool;
	SessionSetAuthKey(ctx context.Context, in *TLSessionSetAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// session.bindAuthKeyUser auth_key_id:long user_id:int = Bool;
	SessionBindAuthKeyUser(ctx context.Context, in *TLSessionBindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Int64, error)
	// session.unbindAuthKeyUser auth_key_id:long user_id:int = Bool;
	SessionUnbindAuthKeyUser(ctx context.Context, in *TLSessionUnbindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Bool, error)
	//
	SessionGetPermAuthKeyId(ctx context.Context, in *mtproto.Int64, opts ...grpc.CallOption) (*mtproto.Int64, error)
	// auth.bindTempAuthKey#cdd42a05 perm_auth_key_id:long nonce:long expires_at:int encrypted_message:bytes = Bool;
	AuthBindTempAuthKey(ctx context.Context, in *mtproto.TLAuthBindTempAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error)
}

type rPCSessionClient struct {
	cc *grpc.ClientConn
}

func NewRPCSessionClient(cc *grpc.ClientConn) RPCSessionClient {
	return &rPCSessionClient{cc}
}

func (c *rPCSessionClient) SessionSetClientSessionInfo(ctx context.Context, in *TLSessionSetClientSessionInfo, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_setClientSessionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetAuthorization(ctx context.Context, in *TLSessionGetAuthorization, opts ...grpc.CallOption) (*mtproto.Authorization, error) {
	out := new(mtproto.Authorization)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getAuthorization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetAuthorizations(ctx context.Context, in *TLSessionGetAuthorizations, opts ...grpc.CallOption) (*mtproto.Account_Authorizations, error) {
	out := new(mtproto.Account_Authorizations)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getAuthorizations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionResetAuthorization(ctx context.Context, in *TLSessionResetAuthorization, opts ...grpc.CallOption) (*VectorLong, error) {
	out := new(VectorLong)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_resetAuthorization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetLayer(ctx context.Context, in *TLSessionGetLayer, opts ...grpc.CallOption) (*mtproto.Int32, error) {
	out := new(mtproto.Int32)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getLayer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetLangCode(ctx context.Context, in *TLSessionGetLangCode, opts ...grpc.CallOption) (*mtproto.String, error) {
	out := new(mtproto.String)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getLangCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetUserId(ctx context.Context, in *TLSessionGetUserId, opts ...grpc.CallOption) (*mtproto.Int32, error) {
	out := new(mtproto.Int32)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getUserId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetPushSessionId(ctx context.Context, in *TLSessionGetPushSessionId, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getPushSessionId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetFutureSalts(ctx context.Context, in *TLSessionGetFutureSalts, opts ...grpc.CallOption) (*mtproto.FutureSalts, error) {
	out := new(mtproto.FutureSalts)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getFutureSalts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionQueryAuthKey(ctx context.Context, in *TLSessionQueryAuthKey, opts ...grpc.CallOption) (*AuthKeyInfo, error) {
	out := new(AuthKeyInfo)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_queryAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionSetAuthKey(ctx context.Context, in *TLSessionSetAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_setAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionBindAuthKeyUser(ctx context.Context, in *TLSessionBindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_bindAuthKeyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionUnbindAuthKeyUser(ctx context.Context, in *TLSessionUnbindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_unbindAuthKeyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) SessionGetPermAuthKeyId(ctx context.Context, in *mtproto.Int64, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/session_getPermAuthKeyId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCSessionClient) AuthBindTempAuthKey(ctx context.Context, in *mtproto.TLAuthBindTempAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsessionpb.RPCSession/auth_bindTempAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RPCSession service

type RPCSessionServer interface {
	// session.setClientSessionInfo session:ClientSession = Bool;
	SessionSetClientSessionInfo(context.Context, *TLSessionSetClientSessionInfo) (*mtproto.Bool, error)
	// session.getAuthorization auth_keyId:long = account.Authorizations;
	SessionGetAuthorization(context.Context, *TLSessionGetAuthorization) (*mtproto.Authorization, error)
	// session.getAuthorizations user_id:int exclude_auth_keyId:long = account.Authorizations;
	SessionGetAuthorizations(context.Context, *TLSessionGetAuthorizations) (*mtproto.Account_Authorizations, error)
	// session.resetAuthorization user_id:int hash:long = Int64;
	SessionResetAuthorization(context.Context, *TLSessionResetAuthorization) (*VectorLong, error)
	// session.getLayer auth_key_id:long = Int32;
	SessionGetLayer(context.Context, *TLSessionGetLayer) (*mtproto.Int32, error)
	// session.getLangCode auth_key_id:long = String;
	SessionGetLangCode(context.Context, *TLSessionGetLangCode) (*mtproto.String, error)
	// session.getUserId auth_key_id:long = Int32;
	SessionGetUserId(context.Context, *TLSessionGetUserId) (*mtproto.Int32, error)
	// session.getPushSessionId user_id:int auth_key_id:long token_type:int = Int64;
	SessionGetPushSessionId(context.Context, *TLSessionGetPushSessionId) (*mtproto.Int64, error)
	// session.getFutureSalts auth_key_id:long num:int = FutureSalts;
	SessionGetFutureSalts(context.Context, *TLSessionGetFutureSalts) (*mtproto.FutureSalts, error)
	// session.queryAuthKey auth_key_id:long = AuthKeyInfo;
	SessionQueryAuthKey(context.Context, *TLSessionQueryAuthKey) (*AuthKeyInfo, error)
	// session.setAuthKey auth_key:AuthKeyInfo = Bool;
	SessionSetAuthKey(context.Context, *TLSessionSetAuthKey) (*mtproto.Bool, error)
	// session.bindAuthKeyUser auth_key_id:long user_id:int = Bool;
	SessionBindAuthKeyUser(context.Context, *TLSessionBindAuthKeyUser) (*mtproto.Int64, error)
	// session.unbindAuthKeyUser auth_key_id:long user_id:int = Bool;
	SessionUnbindAuthKeyUser(context.Context, *TLSessionUnbindAuthKeyUser) (*mtproto.Bool, error)
	//
	SessionGetPermAuthKeyId(context.Context, *mtproto.Int64) (*mtproto.Int64, error)
	// auth.bindTempAuthKey#cdd42a05 perm_auth_key_id:long nonce:long expires_at:int encrypted_message:bytes = Bool;
	AuthBindTempAuthKey(context.Context, *mtproto.TLAuthBindTempAuthKey) (*mtproto.Bool, error)
}

func RegisterRPCSessionServer(s *grpc.Server, srv RPCSessionServer) {
	s.RegisterService(&_RPCSession_serviceDesc, srv)
}

func _RPCSession_SessionSetClientSessionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionSetClientSessionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionSetClientSessionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionSetClientSessionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionSetClientSessionInfo(ctx, req.(*TLSessionSetClientSessionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionGetAuthorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetAuthorization(ctx, req.(*TLSessionGetAuthorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetAuthorizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionGetAuthorizations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetAuthorizations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetAuthorizations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetAuthorizations(ctx, req.(*TLSessionGetAuthorizations))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionResetAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionResetAuthorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionResetAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionResetAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionResetAuthorization(ctx, req.(*TLSessionResetAuthorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionGetLayer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetLayer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetLayer(ctx, req.(*TLSessionGetLayer))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetLangCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionGetLangCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetLangCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetLangCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetLangCode(ctx, req.(*TLSessionGetLangCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionGetUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetUserId(ctx, req.(*TLSessionGetUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetPushSessionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionGetPushSessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetPushSessionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetPushSessionId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetPushSessionId(ctx, req.(*TLSessionGetPushSessionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetFutureSalts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionGetFutureSalts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetFutureSalts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetFutureSalts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetFutureSalts(ctx, req.(*TLSessionGetFutureSalts))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionQueryAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionQueryAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionQueryAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionQueryAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionQueryAuthKey(ctx, req.(*TLSessionQueryAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionSetAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionSetAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionSetAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionSetAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionSetAuthKey(ctx, req.(*TLSessionSetAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionBindAuthKeyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionBindAuthKeyUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionBindAuthKeyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionBindAuthKeyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionBindAuthKeyUser(ctx, req.(*TLSessionBindAuthKeyUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionUnbindAuthKeyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLSessionUnbindAuthKeyUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionUnbindAuthKeyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionUnbindAuthKeyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionUnbindAuthKeyUser(ctx, req.(*TLSessionUnbindAuthKeyUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_SessionGetPermAuthKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mtproto.Int64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).SessionGetPermAuthKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/SessionGetPermAuthKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).SessionGetPermAuthKeyId(ctx, req.(*mtproto.Int64))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCSession_AuthBindTempAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(mtproto.TLAuthBindTempAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCSessionServer).AuthBindTempAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsessionpb.RPCSession/AuthBindTempAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCSessionServer).AuthBindTempAuthKey(ctx, req.(*mtproto.TLAuthBindTempAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCSession_serviceDesc = grpc.ServiceDesc{
	ServiceName: "authsessionpb.RPCSession",
	HandlerType: (*RPCSessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "session_setClientSessionInfo",
			Handler:    _RPCSession_SessionSetClientSessionInfo_Handler,
		},
		{
			MethodName: "session_getAuthorization",
			Handler:    _RPCSession_SessionGetAuthorization_Handler,
		},
		{
			MethodName: "session_getAuthorizations",
			Handler:    _RPCSession_SessionGetAuthorizations_Handler,
		},
		{
			MethodName: "session_resetAuthorization",
			Handler:    _RPCSession_SessionResetAuthorization_Handler,
		},
		{
			MethodName: "session_getLayer",
			Handler:    _RPCSession_SessionGetLayer_Handler,
		},
		{
			MethodName: "session_getLangCode",
			Handler:    _RPCSession_SessionGetLangCode_Handler,
		},
		{
			MethodName: "session_getUserId",
			Handler:    _RPCSession_SessionGetUserId_Handler,
		},
		{
			MethodName: "session_getPushSessionId",
			Handler:    _RPCSession_SessionGetPushSessionId_Handler,
		},
		{
			MethodName: "session_getFutureSalts",
			Handler:    _RPCSession_SessionGetFutureSalts_Handler,
		},
		{
			MethodName: "session_queryAuthKey",
			Handler:    _RPCSession_SessionQueryAuthKey_Handler,
		},
		{
			MethodName: "session_setAuthKey",
			Handler:    _RPCSession_SessionSetAuthKey_Handler,
		},
		{
			MethodName: "session_bindAuthKeyUser",
			Handler:    _RPCSession_SessionBindAuthKeyUser_Handler,
		},
		{
			MethodName: "session_unbindAuthKeyUser",
			Handler:    _RPCSession_SessionUnbindAuthKeyUser_Handler,
		},
		{
			MethodName: "session_getPermAuthKeyId",
			Handler:    _RPCSession_SessionGetPermAuthKeyId_Handler,
		},
		{
			MethodName: "auth_bindTempAuthKey",
			Handler:    _RPCSession_AuthBindTempAuthKey_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "authsessionpb.tl.proto",
}

func (m *AuthKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PredicateName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.PredicateName)))
		i += copy(dAtA[i:], m.PredicateName)
	}
	if m.Constructor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if len(m.AuthKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.AuthKey)))
		i += copy(dAtA[i:], m.AuthKey)
	}
	if m.AuthKeyType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyType))
	}
	if m.PermAuthKeyId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.PermAuthKeyId))
	}
	if m.TempAuthKeyId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.TempAuthKeyId))
	}
	if m.MediaTempAuthKeyId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.MediaTempAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLAuthKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Data2.Size()))
		n1, err := m.Data2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ClientSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSession) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PredicateName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.PredicateName)))
		i += copy(dAtA[i:], m.PredicateName)
	}
	if m.Constructor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if len(m.Ip) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.Ip)))
		i += copy(dAtA[i:], m.Ip)
	}
	if m.Layer != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Layer))
	}
	if m.ApiId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.ApiId))
	}
	if len(m.DeviceModel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.DeviceModel)))
		i += copy(dAtA[i:], m.DeviceModel)
	}
	if len(m.SystemVersion) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.SystemVersion)))
		i += copy(dAtA[i:], m.SystemVersion)
	}
	if len(m.AppVersion) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.AppVersion)))
		i += copy(dAtA[i:], m.AppVersion)
	}
	if len(m.SystemLangCode) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.SystemLangCode)))
		i += copy(dAtA[i:], m.SystemLangCode)
	}
	if len(m.LangPack) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.LangPack)))
		i += copy(dAtA[i:], m.LangPack)
	}
	if len(m.LangCode) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.LangCode)))
		i += copy(dAtA[i:], m.LangCode)
	}
	if len(m.Proxy) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.Proxy)))
		i += copy(dAtA[i:], m.Proxy)
	}
	if len(m.Params) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(len(m.Params)))
		i += copy(dAtA[i:], m.Params)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLClientSessionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLClientSessionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Data2.Size()))
		n2, err := m.Data2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionSetClientSessionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionSetClientSessionInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.Session != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Session.Size()))
		n3, err := m.Session.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionGetAuthorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionGetAuthorization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionGetAuthorizations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionGetAuthorizations) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.UserId))
	}
	if m.ExcludeAuthKeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.ExcludeAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionResetAuthorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionResetAuthorization) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.Hash != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Hash))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionGetLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionGetLayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionGetLangCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionGetLangCode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionGetUserId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionGetUserId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionGetPushSessionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionGetPushSessionId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.TokenType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.TokenType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionGetFutureSalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionGetFutureSalts) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.Num != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionQueryAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionQueryAuthKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionSetAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionSetAuthKey) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKey != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKey.Size()))
		n4, err := m.AuthKey.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.FutureSalt != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.FutureSalt.Size()))
		n5, err := m.FutureSalt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionBindAuthKeyUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionBindAuthKeyUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TLSessionUnbindAuthKeyUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLSessionUnbindAuthKeyUser) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Constructor != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *VectorLong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VectorLong) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Datas) > 0 {
		dAtA7 := make([]byte, len(m.Datas)*10)
		var j6 int
		for _, num1 := range m.Datas {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyStateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyStateData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.UserId))
	}
	if m.KeyState != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.KeyState))
	}
	if m.ClientType != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.ClientType))
	}
	if m.Layer != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.Layer))
	}
	if m.AndroidPushSessionId != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintAuthsessionpbTl(dAtA, i, uint64(m.AndroidPushSessionId))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintAuthsessionpbTl(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *AuthKeyInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.AuthKeyType != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyType))
	}
	if m.PermAuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.PermAuthKeyId))
	}
	if m.TempAuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.TempAuthKeyId))
	}
	if m.MediaTempAuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.MediaTempAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthKeyInfo) Size() (n int) {
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientSession) Size() (n int) {
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Layer))
	}
	if m.ApiId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	l = len(m.SystemLangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	l = len(m.LangPack)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLClientSessionInfo) Size() (n int) {
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionSetClientSessionInfo) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.Session != nil {
		l = m.Session.Size()
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionGetAuthorization) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionGetAuthorizations) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.UserId))
	}
	if m.ExcludeAuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.ExcludeAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionResetAuthorization) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.Hash != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Hash))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionGetLayer) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionGetLangCode) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionGetUserId) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionGetPushSessionId) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.TokenType != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.TokenType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionGetFutureSalts) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.Num != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionQueryAuthKey) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionSetAuthKey) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKey != nil {
		l = m.AuthKey.Size()
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.FutureSalt != nil {
		l = m.FutureSalt.Size()
		n += 1 + l + sovAuthsessionpbTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionBindAuthKeyUser) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLSessionUnbindAuthKeyUser) Size() (n int) {
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VectorLong) Size() (n int) {
	var l int
	_ = l
	if len(m.Datas) > 0 {
		l = 0
		for _, e := range m.Datas {
			l += sovAuthsessionpbTl(uint64(e))
		}
		n += 1 + sovAuthsessionpbTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyStateData) Size() (n int) {
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.UserId))
	}
	if m.KeyState != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.KeyState))
	}
	if m.ClientType != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.ClientType))
	}
	if m.Layer != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.Layer))
	}
	if m.AndroidPushSessionId != 0 {
		n += 1 + sovAuthsessionpbTl(uint64(m.AndroidPushSessionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAuthsessionpbTl(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAuthsessionpbTl(x uint64) (n int) {
	return sovAuthsessionpbTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyType", wireType)
			}
			m.AuthKeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermAuthKeyId", wireType)
			}
			m.PermAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempAuthKeyId", wireType)
			}
			m.TempAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MediaTempAuthKeyId", wireType)
			}
			m.MediaTempAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MediaTempAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &AuthKeyInfo{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemLangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangPack", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangPack = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLClientSessionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_clientSessionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_clientSessionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &ClientSession{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionSetClientSessionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_setClientSessionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_setClientSessionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Session", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Session == nil {
				m.Session = &ClientSession{}
			}
			if err := m.Session.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionGetAuthorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_getAuthorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_getAuthorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionGetAuthorizations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_getAuthorizations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_getAuthorizations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeAuthKeyId", wireType)
			}
			m.ExcludeAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExcludeAuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionResetAuthorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_resetAuthorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_resetAuthorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionGetLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_getLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_getLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionGetLangCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_getLangCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_getLangCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionGetUserId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_getUserId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_getUserId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionGetPushSessionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_getPushSessionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_getPushSessionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			m.TokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionGetFutureSalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_getFutureSalts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_getFutureSalts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionQueryAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_queryAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_queryAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionSetAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_setAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_setAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthKey == nil {
				m.AuthKey = &AuthKeyInfo{}
			}
			if err := m.AuthKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureSalt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FutureSalt == nil {
				m.FutureSalt = &mtproto.FutureSalt{}
			}
			if err := m.FutureSalt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionBindAuthKeyUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_bindAuthKeyUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_bindAuthKeyUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLSessionUnbindAuthKeyUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_session_unbindAuthKeyUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_session_unbindAuthKeyUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= (TLConstructor(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VectorLong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_long: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_long: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthsessionpbTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Datas = append(m.Datas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthsessionpbTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAuthsessionpbTl
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthsessionpbTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Datas = append(m.Datas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyStateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyStateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyStateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyState", wireType)
			}
			m.KeyState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyState |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPushSessionId", wireType)
			}
			m.AndroidPushSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AndroidPushSessionId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionpbTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAuthsessionpbTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthsessionpbTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthsessionpbTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthsessionpbTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAuthsessionpbTl
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAuthsessionpbTl
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAuthsessionpbTl(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAuthsessionpbTl = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthsessionpbTl   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("authsessionpb.tl.proto", fileDescriptor_authsessionpb_tl_5282a1203cd8149c)
}

var fileDescriptor_authsessionpb_tl_5282a1203cd8149c = []byte{
	// 1344 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x6e, 0x1b, 0xd5,
	0x17, 0xf7, 0xc4, 0x71, 0x12, 0x1f, 0xc7, 0xf9, 0xbb, 0xb7, 0x6e, 0xe2, 0x4c, 0xd3, 0xd4, 0xff,
	0x29, 0xa5, 0xa6, 0x14, 0x1b, 0xb9, 0x1f, 0x0b, 0x84, 0x90, 0x5a, 0x23, 0x44, 0x1a, 0x93, 0x56,
	0x93, 0xb4, 0x40, 0x85, 0x34, 0xdc, 0xcc, 0xdc, 0xd8, 0xa3, 0xcc, 0x17, 0x73, 0xef, 0x54, 0x35,
	0xe2, 0x01, 0xd8, 0xb0, 0x44, 0x88, 0x35, 0x62, 0x83, 0xd8, 0xf2, 0x06, 0x2c, 0x58, 0x56, 0xec,
	0xd8, 0x41, 0x9f, 0x80, 0x47, 0x40, 0xf7, 0xce, 0x78, 0x3c, 0x1f, 0xb6, 0x03, 0xb4, 0x11, 0xdd,
	0xcd, 0x9c, 0xf3, 0xbb, 0xe7, 0xfc, 0xe6, 0x7c, 0xdc, 0x73, 0x34, 0xb0, 0x8e, 0x03, 0x36, 0xa4,
	0x84, 0x52, 0xd3, 0x75, 0xbc, 0xc3, 0x36, 0xb3, 0xda, 0x9e, 0xef, 0x32, 0x17, 0x55, 0x53, 0x72,
	0xf9, 0x8d, 0x81, 0xc9, 0x86, 0xc1, 0x61, 0x5b, 0x77, 0xed, 0xce, 0xc0, 0x1d, 0xb8, 0x1d, 0x81,
	0x3a, 0x0c, 0x8e, 0xc4, 0x9b, 0x78, 0x11, 0x4f, 0xe1, 0x69, 0x59, 0xa6, 0xfa, 0x90, 0xd8, 0x98,
	0x9b, 0xd3, 0x5d, 0x9f, 0x68, 0x6c, 0xe4, 0x11, 0x1a, 0xe9, 0x36, 0x27, 0x3a, 0xe6, 0x63, 0x87,
	0x7a, 0xae, 0xcf, 0x22, 0x55, 0x7d, 0xa2, 0xa2, 0x23, 0x47, 0x8f, 0xa4, 0x5b, 0x69, 0xa9, 0x46,
	0x89, 0xff, 0xd8, 0xd4, 0x49, 0xa8, 0x55, 0x7e, 0x5b, 0x80, 0xca, 0xed, 0x80, 0x0d, 0x77, 0xc9,
	0x68, 0xc7, 0x39, 0x72, 0xd1, 0x65, 0x58, 0xf3, 0x7c, 0x62, 0x98, 0x3a, 0x66, 0x44, 0x73, 0xb0,
	0x4d, 0x1a, 0x52, 0x53, 0x6a, 0x95, 0xd5, 0x6a, 0x2c, 0xdd, 0xc3, 0x36, 0x41, 0xef, 0x40, 0x45,
	0x77, 0x1d, 0xca, 0xfc, 0x40, 0x67, 0xae, 0xdf, 0x58, 0x68, 0x4a, 0xad, 0xb5, 0xee, 0x56, 0x3b,
	0x1d, 0x8d, 0x83, 0x7e, 0x6f, 0x82, 0x51, 0x93, 0x07, 0xd0, 0x36, 0x54, 0x38, 0x56, 0x3b, 0x26,
	0x23, 0xcd, 0x34, 0x1a, 0xc5, 0xa6, 0xd4, 0x2a, 0xaa, 0x65, 0x1c, 0x11, 0x31, 0xd0, 0x26, 0xac,
	0x8c, 0xf5, 0x8d, 0xc5, 0xa6, 0xd4, 0x5a, 0x55, 0x97, 0x23, 0x25, 0x52, 0xa0, 0x1a, 0x1f, 0xe5,
	0x81, 0x69, 0x94, 0x9a, 0x52, 0xab, 0xa4, 0x56, 0x22, 0xfd, 0xc1, 0xc8, 0x23, 0xe8, 0x0a, 0xd4,
	0x3c, 0xe2, 0xdb, 0x5a, 0xd2, 0xc7, 0x92, 0xf0, 0x51, 0xe5, 0xf2, 0xdb, 0xb1, 0x9f, 0x2b, 0x50,
	0x63, 0xc4, 0xf6, 0x52, 0xc0, 0xe5, 0x10, 0xc8, 0xe5, 0x13, 0x60, 0x17, 0xd6, 0x6d, 0x62, 0x98,
	0x58, 0xcb, 0xc1, 0x57, 0x04, 0x1c, 0x09, 0xed, 0x41, 0xf2, 0x8c, 0x72, 0x07, 0xd6, 0x0e, 0xfa,
	0x1a, 0x4e, 0x44, 0xf7, 0x4d, 0x28, 0x19, 0x98, 0xe1, 0xae, 0x08, 0x6a, 0xa5, 0x2b, 0x67, 0x02,
	0x96, 0x48, 0x84, 0x1a, 0x02, 0x95, 0xa7, 0x45, 0xa8, 0xf6, 0x2c, 0x93, 0x38, 0x6c, 0x3f, 0x84,
	0xbd, 0x2c, 0x19, 0x5a, 0x83, 0x05, 0xd3, 0x13, 0xb9, 0x29, 0xab, 0x0b, 0xa6, 0x87, 0xea, 0x50,
	0xb2, 0xf0, 0x88, 0xf8, 0x51, 0x3a, 0xc2, 0x17, 0x74, 0x0e, 0x96, 0xb0, 0x67, 0x8e, 0xc3, 0x5f,
	0x52, 0x4b, 0xd8, 0x33, 0x77, 0x0c, 0xf4, 0x7f, 0x58, 0x35, 0x08, 0xaf, 0x42, 0xcd, 0x76, 0x0d,
	0x62, 0x89, 0x90, 0x97, 0xd5, 0x4a, 0x28, 0xfb, 0x80, 0x8b, 0xf8, 0x67, 0xd2, 0x11, 0x65, 0xc4,
	0xd6, 0x1e, 0x13, 0x9f, 0xd3, 0x15, 0x81, 0x2e, 0xab, 0xd5, 0x50, 0xfa, 0x30, 0x14, 0xa2, 0x8b,
	0x50, 0xc1, 0x9e, 0x17, 0x63, 0xca, 0x02, 0x03, 0xd8, 0xf3, 0xc6, 0x80, 0x16, 0xd4, 0x22, 0x3b,
	0x16, 0x76, 0x06, 0x9a, 0xee, 0x1a, 0xa4, 0x01, 0x02, 0x15, 0xd9, 0xef, 0x63, 0x67, 0xd0, 0x73,
	0x0d, 0x82, 0xce, 0x43, 0x59, 0x40, 0x3c, 0xac, 0x1f, 0x37, 0x2a, 0x02, 0xb2, 0xc2, 0x05, 0xf7,
	0xb1, 0x7e, 0x1c, 0x2b, 0xc5, 0xf9, 0xd5, 0x89, 0x52, 0x9c, 0xac, 0x43, 0xc9, 0xf3, 0xdd, 0x27,
	0xa3, 0x46, 0x55, 0x28, 0xc2, 0x17, 0xb4, 0x0e, 0x4b, 0x1e, 0xf6, 0xb1, 0x4d, 0x1b, 0x6b, 0x42,
	0x1c, 0xbd, 0x29, 0x77, 0xa1, 0x7e, 0xd0, 0xd7, 0xf4, 0x64, 0x52, 0x45, 0x71, 0x74, 0xd3, 0xc5,
	0x91, 0xcd, 0x55, 0xaa, 0x0a, 0xc6, 0xe5, 0xf1, 0xad, 0x04, 0x17, 0x0f, 0xfa, 0x5a, 0x84, 0xd2,
	0x28, 0x61, 0xbd, 0x9c, 0xdd, 0x4c, 0x25, 0x48, 0xff, 0xb4, 0x12, 0x6e, 0xc1, 0x72, 0x84, 0x13,
	0x55, 0x70, 0x12, 0xb3, 0x31, 0x58, 0xf9, 0x02, 0xce, 0x27, 0xa8, 0x0d, 0x08, 0xe3, 0xe5, 0xed,
	0xfa, 0xe6, 0xe7, 0x98, 0xf1, 0xc4, 0x3c, 0x2f, 0xad, 0x0b, 0x00, 0xe3, 0x02, 0xdd, 0xc9, 0xd7,
	0xa7, 0xf2, 0xbd, 0x04, 0x5b, 0x73, 0xdc, 0xd3, 0xe7, 0xf6, 0xbf, 0x01, 0xcb, 0x01, 0x25, 0xfe,
	0xb8, 0x39, 0x4a, 0xea, 0x12, 0x7f, 0xdd, 0x31, 0xd0, 0x35, 0x40, 0xe4, 0x89, 0x6e, 0x05, 0x06,
	0xd1, 0x12, 0x04, 0x17, 0x05, 0xc1, 0x5a, 0xa4, 0x99, 0x5c, 0x12, 0x3f, 0x4a, 0x70, 0x21, 0xc1,
	0xd3, 0x27, 0xf4, 0x45, 0x07, 0x6a, 0x26, 0xd1, 0x4c, 0x8b, 0x2f, 0x66, 0x5b, 0x1c, 0xc1, 0xe2,
	0x10, 0xd3, 0xa1, 0xe8, 0xe8, 0xa2, 0x2a, 0x9e, 0x95, 0x00, 0xce, 0xa6, 0xa3, 0xda, 0x17, 0x7d,
	0xfe, 0xbc, 0x1c, 0x4f, 0xb8, 0x6d, 0x94, 0x27, 0xb0, 0x9e, 0x75, 0x1b, 0xf5, 0xde, 0x69, 0x7b,
	0x7e, 0x2c, 0xba, 0x35, 0xe1, 0xf9, 0x41, 0x18, 0xbc, 0xd3, 0xf6, 0xfb, 0x93, 0x94, 0x6d, 0x9f,
	0xfb, 0x01, 0x1d, 0x8e, 0xfb, 0xda, 0xf8, 0xef, 0xaa, 0xe2, 0x02, 0x00, 0x73, 0x8f, 0x89, 0x93,
	0x1c, 0xbe, 0x65, 0x21, 0xe1, 0xa3, 0x57, 0xf9, 0x4a, 0x82, 0xcd, 0x34, 0xef, 0xf7, 0x02, 0x16,
	0xf8, 0x64, 0x1f, 0x5b, 0x8c, 0x9e, 0x76, 0xd4, 0x50, 0x0d, 0x8a, 0x4e, 0x60, 0x0b, 0xd2, 0x25,
	0x95, 0x3f, 0x2a, 0x23, 0xd8, 0x48, 0xd0, 0xf9, 0x2c, 0x20, 0xfe, 0x28, 0x6a, 0xbe, 0x53, 0x4f,
	0xe1, 0xcf, 0x12, 0x9c, 0x4b, 0x5f, 0xce, 0x2f, 0xca, 0xf3, 0xcd, 0xc4, 0x7a, 0xb4, 0x70, 0xe2,
	0x2a, 0x11, 0xaf, 0x4e, 0x37, 0xa0, 0x72, 0x24, 0x92, 0xa1, 0x51, 0x6c, 0xb1, 0xe8, 0x36, 0x3f,
	0xdb, 0xb6, 0x99, 0xd8, 0x05, 0xdb, 0x93, 0x44, 0xa9, 0x70, 0x14, 0x3f, 0x2b, 0x5f, 0x4b, 0x20,
	0x27, 0x3e, 0xe3, 0xd0, 0x74, 0x8c, 0xc8, 0x3a, 0x6f, 0x85, 0x53, 0x4f, 0x69, 0xa2, 0x50, 0x17,
	0x93, 0x85, 0xaa, 0x7c, 0x93, 0xbe, 0xe1, 0x03, 0xe7, 0xa5, 0x61, 0x76, 0x09, 0x2a, 0x0f, 0x09,
	0x37, 0xa1, 0x59, 0xae, 0x33, 0xe0, 0xeb, 0x01, 0x9f, 0xd6, 0xb4, 0x21, 0x35, 0x8b, 0xad, 0x62,
	0x38, 0xba, 0xa9, 0xf2, 0xab, 0x04, 0xab, 0xbb, 0x64, 0xb4, 0xcf, 0x30, 0x23, 0xef, 0x62, 0x86,
	0xff, 0xb5, 0x3b, 0xbe, 0x9b, 0xf0, 0x33, 0x94, 0x5b, 0x8a, 0x1a, 0x72, 0xe5, 0x38, 0xb2, 0xcc,
	0x17, 0xa4, 0x70, 0xd5, 0x08, 0xfb, 0x35, 0x5c, 0xc3, 0x20, 0x14, 0x89, 0x5d, 0x39, 0x5e, 0xdc,
	0x96, 0x93, 0x8b, 0xdb, 0x4d, 0xd8, 0xc0, 0x8e, 0xe1, 0xbb, 0xa6, 0xa1, 0x79, 0x01, 0x1d, 0xc6,
	0x51, 0x8e, 0x17, 0xde, 0x7a, 0xa4, 0x4e, 0xdd, 0x4a, 0x57, 0x5b, 0x50, 0x4d, 0x05, 0x14, 0x9d,
	0x81, 0x6a, 0x4f, 0xed, 0x5d, 0xef, 0x6a, 0x0f, 0xf6, 0x76, 0xf7, 0xee, 0x7d, 0xb8, 0x57, 0x2b,
	0xc8, 0x8b, 0x5f, 0x7e, 0xb7, 0x5d, 0xe8, 0xfe, 0x00, 0x00, 0xea, 0xfd, 0xde, 0x78, 0xab, 0xd5,
	0x60, 0x6b, 0xee, 0x12, 0xd3, 0xce, 0xa5, 0x6d, 0xee, 0xd2, 0x23, 0x57, 0xe3, 0xaa, 0xbe, 0xe3,
	0xba, 0x96, 0x52, 0x40, 0x9f, 0x42, 0x63, 0xe6, 0x2a, 0x72, 0x75, 0xb6, 0xf1, 0x2c, 0x56, 0x5e,
	0x8f, 0x0d, 0xa7, 0xe4, 0x4a, 0x01, 0x1d, 0xc3, 0xe6, 0xec, 0x6d, 0xe3, 0xf5, 0xbf, 0xef, 0x82,
	0xca, 0x17, 0x63, 0x1f, 0x58, 0xd7, 0xdd, 0xc0, 0x61, 0x5a, 0x1a, 0xa0, 0x14, 0xd0, 0x10, 0xe4,
	0x39, 0x2b, 0xc3, 0xb5, 0xd9, 0xde, 0xf2, 0x68, 0x39, 0x7b, 0x77, 0x24, 0x6a, 0x57, 0x29, 0xa0,
	0xf7, 0xa1, 0x96, 0x1b, 0xf7, 0xca, 0xdc, 0xaf, 0x11, 0x18, 0x79, 0x2d, 0xfe, 0x88, 0x1d, 0x87,
	0x5d, 0xef, 0x2a, 0x05, 0x74, 0x0f, 0xce, 0x4e, 0x9b, 0xe0, 0x97, 0x4f, 0x30, 0x16, 0xc2, 0xe4,
	0xff, 0xc5, 0xf6, 0xf6, 0x99, 0x6f, 0x0a, 0x6a, 0x77, 0xe1, 0x4c, 0x7e, 0x30, 0x5f, 0x9a, 0x6b,
	0x2e, 0x04, 0x4d, 0x21, 0xf7, 0x51, 0xaa, 0x3e, 0xd2, 0xb3, 0x76, 0x7e, 0x7d, 0xa4, 0xb0, 0x69,
	0xcb, 0xb7, 0x6e, 0x28, 0x05, 0xf4, 0x08, 0xd6, 0x67, 0x4c, 0xc3, 0xd6, 0x5c, 0xbb, 0x09, 0xa4,
	0x5c, 0x9f, 0x72, 0x49, 0xf3, 0x32, 0xf8, 0x04, 0xea, 0x53, 0x47, 0xdb, 0xab, 0xb3, 0x2d, 0x27,
	0x71, 0xf2, 0x9c, 0xb1, 0xa1, 0x14, 0xd0, 0x2e, 0xa0, 0x29, 0xc3, 0xeb, 0x95, 0xb9, 0xad, 0x38,
	0xb6, 0x9c, 0x6b, 0xc0, 0x87, 0xb0, 0x31, 0x6b, 0x84, 0xbc, 0x36, 0xdb, 0x62, 0x06, 0x3a, 0x25,
	0xbc, 0x1f, 0x4f, 0xda, 0x2e, 0x3f, 0x02, 0xe6, 0xb4, 0x5d, 0x0e, 0x9c, 0xa7, 0xfc, 0x76, 0xba,
	0x26, 0x52, 0x7f, 0x0e, 0x32, 0x44, 0xa6, 0x10, 0xdb, 0x81, 0xba, 0xb8, 0xcf, 0xb9, 0x9b, 0xc4,
	0x8f, 0x01, 0xd4, 0x8c, 0x91, 0xd1, 0xdf, 0x81, 0x2c, 0x22, 0x47, 0xe4, 0x4e, 0xff, 0xcf, 0x3f,
	0xb6, 0xa5, 0x5f, 0x9e, 0x6d, 0x4b, 0x4f, 0x9f, 0x6d, 0x4b, 0xbf, 0x3f, 0xdb, 0x96, 0x1e, 0xbd,
	0xe5, 0x90, 0xc3, 0xc0, 0xc2, 0x6d, 0x7d, 0x88, 0x59, 0x47, 0xb7, 0x02, 0xca, 0x88, 0xdf, 0xc1,
	0x9e, 0xd7, 0x89, 0x7e, 0xef, 0x74, 0x84, 0xe1, 0x88, 0x7d, 0x27, 0x15, 0x84, 0xc3, 0x25, 0x61,
	0xfb, 0xfa, 0x5f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xc7, 0x69, 0x04, 0x34, 0xbd, 0x12, 0x00, 0x00,
}
